---
title: Android-éŸ³è§†é¢‘-éŸ³é¢‘å¼€å‘-ï¼ˆä¸‰ï¼‰éŸ³é¢‘ç¼–è§£ç 
categories:
  - ğŸŒ™åŸºç¡€å­¦ä¹ 
  - â­Android
abbrlink: f3f6a8c1
date: 2021-09-19 15:42:43
tags:
---

### MediaCodec

Android å®˜æ–¹æä¾›çš„éŸ³é¢‘ç¼–è§£ç çš„ APIï¼Œå³ MediaCodec ç±»ï¼Œè¯¥ API æ˜¯åœ¨ Andorid 4.1 ï¼ˆAPI 16ï¼‰ ç‰ˆæœ¬å¼•å…¥çš„ï¼Œå› æ­¤åªèƒ½å·¥ä½œäº Android 4.1 ä»¥ä¸Šçš„æ‰‹æœºä¸Šã€‚

***

#### MediaCodec åŸºæœ¬ä»‹ç»

1. æä¾›äº†ä¸€å¥—è®¿é—® Android åº•å±‚å¤šåª’ä½“æ¨¡å—çš„æ¥å£ï¼Œä¸»è¦æ˜¯éŸ³è§†é¢‘çš„ç¼–è§£ç æ¥å£

2. Android åº•å±‚å¤šåª’ä½“æ¨¡å—é‡‡ç”¨çš„æ˜¯ OpenMax æ¡†æ¶ï¼Œä»»ä½• Android åº•å±‚ç¼–è§£ç æ¨¡å—çš„å®ç°ï¼Œéƒ½å¿…é¡»éµå¾ª OpenMax æ ‡å‡†ã€‚ï¼ˆç¡¬ä»¶ç¼–è§£ç åŠŸèƒ½ï¼Œåˆ™éœ€è¦ç”±èŠ¯ç‰‡å‚å•†ä¾ç…§ OpenMax æ¡†æ¶æ ‡å‡†æ¥å®Œæˆï¼Œæ‰€ä»¥ï¼Œä¸€èˆ¬é‡‡ç”¨ä¸åŒèŠ¯ç‰‡å‹å·çš„æ‰‹æœºï¼Œç¡¬ä»¶ç¼–è§£ç çš„å®ç°å’Œæ€§èƒ½æ˜¯ä¸åŒçš„ï¼‰

<!--more-->

3. Android åº”ç”¨å±‚ç»Ÿä¸€ç”± MediaCodec API æ¥æä¾›å„ç§éŸ³è§†é¢‘ç¼–è§£ç åŠŸèƒ½ï¼Œç”±å‚æ•°é…ç½®æ¥å†³å®šé‡‡ç”¨ä½•ç§ç¼–è§£ç ç®—æ³•ã€æ˜¯å¦é‡‡ç”¨ç¡¬ä»¶ç¼–è§£ç åŠ é€Ÿç­‰ç­‰

{% asset_img 1.webp %}

***

#### MediaCodecç”Ÿå‘½å‘¨æœŸå’ŒçŠ¶æ€

åŒæ­¥ï¼ˆä¸Šï¼‰ä¸å¼‚æ­¥ï¼ˆä¸‹ï¼‰

{% asset_img 2.webp %}

{% asset_img 3.webp %}

- **Uninitialized**ï¼šå½“é€šè¿‡å·¥å‚æ–¹æ³•äº†æˆåŠŸåˆ›å»ºç¼–è§£ç å™¨åï¼Œæ­¤æ—¶å¤„äºUninitializedå­çŠ¶æ€

- **Configured**ï¼šé€šè¿‡configureæ–¹æ³•é…ç½®ç¼–è§£ç å™¨ï¼Œæ­¤æ—¶å¤„äºConfiguredå­çŠ¶æ€ï¼Œæ¥ç€ï¼Œéœ€è¦è°ƒç”¨startæ–¹æ³•æ¥å¯åŠ¨ï¼Œè®©ç¼–è§£ç å™¨è¿›å…¥ExecutingçŠ¶æ€çš„Flushedå­çŠ¶æ€ï¼Œæ‰èƒ½è¾“å…¥æ•°æ®ç»™ç¼–è§£ç å™¨å¤„ç†

- **Flushed**ï¼šæ‰§è¡Œstartæ–¹æ³•åï¼Œæ­¤æ—¶å¤„äºFlushedå­çŠ¶æ€

- **Running**ï¼šå½“ç¬¬ä¸€ä¸ªè¾“å…¥ç¼“å†²åŒºè¢«å‡ºé˜Ÿï¼Œç¼–è§£ç å™¨ä¾¿è¿›å…¥Runningå­çŠ¶æ€ï¼Œè¿™æ„å‘³ç€å¤§éƒ¨åˆ†æ—¶é—´ç¼–è§£ç å™¨éƒ½å¤„äºæ­¤çŠ¶æ€

- **End-of-Stream**ï¼šå½“ç»™ç¼–è§£ç å™¨å‘é€ä¸€ä¸ªå¸¦æœ‰End-of-Streamæ ‡è®°çš„Bufferåï¼Œç¼–è§£ç å™¨å°±åˆ‡æ¢ä¸ºEnd-of-Streamå­çŠ¶æ€ï¼Œæ­¤æ—¶ï¼Œç¼–è§£ç å™¨ä¸å†æ¥æ”¶è¾“å…¥æ•°æ®ï¼Œä½†ä»æ—§ä¼šç»§ç»­è¾“å‡ºï¼Œç›´åˆ°end-of-streamæ ‡è®°è¾“å‡º

- **Released**ï¼šStoppedå’ŒExecutingéƒ½å¯åˆ‡æ¢è‡³æ­¤çŠ¶æ€ï¼Œå½“ä½¿ç”¨ç¼–ç å™¨æ“ä½œå®Œæˆåï¼Œåº”è¯¥è°ƒç”¨releaseæ–¹æ³•ï¼Œä½¿ç¼–è§£ç å™¨è¿›å…¥æ­¤çŠ¶æ€

çŠ¶æ€åˆ‡æ¢ï¼š

- **flush()**ï¼šExecuting â†’ Flushed

- **stop()**ï¼šExecuting â†’ Uninitializedï¼Œæ­¤æ—¶å¯ä»¥è°ƒç”¨configureæ–¹æ³•æ¥é‡æ–°é…ç½®ï¼Œè¿›å…¥ä¸‹ä¸€è½®å¾ªç¯

- **reset()**ï¼šany â†’ Uninitializedï¼Œresetå¯ä»¥åœ¨ä»»ä½•æ—¶å€™è¢«è°ƒç”¨ã€‚åœ¨æŸäº›æƒ…å†µä¸‹ï¼Œç¼–è§£ç å™¨ä¼šå‡ºç°å¼‚å¸¸ï¼Œæ­¤æ—¶åº”è¯¥ä½¿ç”¨resetè€Œä¸æ˜¯stopæ–¹æ³•

- **release()**ï¼šä¸å‡†å¤‡é‡æ–°ä½¿ç”¨ç¼–è§£ç å™¨ï¼Œé‚£åº”è¯¥è°ƒç”¨releaseè¿›è¡Œé‡Šæ”¾

***

#### MediaCodec API è¯´æ˜

getInputBuffers()ï¼šè·å–éœ€è¦ç¼–ç æ•°æ®çš„è¾“å…¥æµé˜Ÿåˆ—ï¼Œè¿”å›çš„æ˜¯ä¸€ä¸ªByteBufferæ•°ç»„

queueInputBuffer()ï¼šè¾“å…¥æµå…¥é˜Ÿåˆ—

dequeueInputBuffer()ï¼šä»è¾“å…¥æµé˜Ÿåˆ—ä¸­å–æ•°æ®è¿›è¡Œç¼–ç æ“ä½œ

getOutputBuffers()ï¼šè·å–ç¼–è§£ç ä¹‹åçš„æ•°æ®è¾“å‡ºæµé˜Ÿåˆ—ï¼Œè¿”å›çš„æ˜¯ä¸€ä¸ªByteBufferæ•°ç»„

dequeueOutputBuffer()ï¼šä»è¾“å‡ºé˜Ÿåˆ—ä¸­å–å‡ºç¼–ç æ“ä½œä¹‹åçš„æ•°æ®

releaseOutputBuffer()ï¼šå¤„ç†å®Œæˆï¼Œé‡Šæ”¾ByteBufferæ•°æ®

***

#### MediaCodec æ ¸å¿ƒåŸç†

``` shell
- createEncoderByType/createDecoderByType
- configure
- start
- while(1) {
    - dequeueInputBuffer
    - queueInputBuffer
    - dequeueOutputBuffer
    - releaseOutputBuffer
}
- stop
- release
```

Buffer é˜Ÿåˆ—çš„æ“ä½œæ˜¯å…¶æœ€æ ¸å¿ƒçš„éƒ¨åˆ†ä¹‹ä¸€ï¼Œå…³äº MediaCodec çš„ Buffer é˜Ÿåˆ— ï¼Œç¤ºæ„å›¾å¦‚ä¸‹ï¼š

{% asset_img 4.webp %}

MediaCodec æ¶æ„ä¸Šé‡‡ç”¨äº†2ä¸ªç¼“å†²åŒºé˜Ÿåˆ—ï¼Œå¼‚æ­¥å¤„ç†æ•°æ®ï¼š

1. Client ä» input ç¼“å†²åŒºé˜Ÿåˆ—ç”³è¯· empty buffer **[dequeueInputBuffer]**

2. Client æŠŠéœ€è¦ç¼–è§£ç çš„æ•°æ®æ‹·è´åˆ° empty bufferï¼Œç„¶åæ”¾å…¥ input ç¼“å†²åŒºé˜Ÿåˆ— **[queueInputBuffer]**

3. MediaCodec æ¨¡å—ä» input ç¼“å†²åŒºé˜Ÿåˆ—å–ä¸€å¸§æ•°æ®è¿›è¡Œç¼–è§£ç å¤„ç†

4. ç¼–è§£ç å¤„ç†ç»“æŸåï¼ŒMediaCodec å°†åŸå§‹æ•°æ® buffer ç½®ä¸º empty åæ”¾å› input ç¼“å†²åŒºé˜Ÿåˆ—ï¼Œå°†ç¼–è§£ç åçš„æ•°æ®æ”¾å…¥åˆ° output ç¼“å†²åŒºé˜Ÿåˆ—

5. Client ä» output ç¼“å†²åŒºé˜Ÿåˆ—ç”³è¯·ç¼–è§£ç åçš„ buffer **[dequeueOutputBuffer]**

6. Client å¯¹ç¼–è§£ç åçš„ buffer è¿›è¡Œæ¸²æŸ“/æ’­æ”¾

7. æ¸²æŸ“/æ’­æ”¾å®Œæˆåï¼ŒClient å†å°†è¯¥ buffer æ”¾å› output ç¼“å†²åŒºé˜Ÿåˆ— **[releaseOutputBuffer]**

MediaCodec åœ¨æ¶æ„ä¸Šï¼Œå…¶å®æ˜¯é‡‡ç”¨äº†ä¸€ç§åŸºäºâ€œç¯å½¢ç¼“å†²åŒºâ€çš„â€œç”Ÿäº§è€…-æ¶ˆè´¹è€…â€æ¨¡å¼ï¼Œå®ƒè®¾è®¡äº† 2 ä¸ªåŸºäº idx åºå·çš„â€œç¯å½¢ç¼“å†²åŒºâ€ï¼š

{% asset_img 5.webp %}

***

#### MediaCodecç¼–ç ä¾‹å­ï¼ˆåŒæ­¥ï¼‰

ä½¿ç”¨AudioRecordå½•åˆ¶éŸ³é¢‘ï¼ŒMediaCodecç¼–ç ä¸ºAAC

è¿‡ç¨‹æ­¥éª¤ï¼šï¼ˆåŸºäºï¼ˆäºŒï¼‰çš„doStart()ä¸­whileå¾ªç¯å–å¾—çš„å…ƒæ•°æ®ï¼‰

AudioRecorder åŸºæœ¬ä½¿ç”¨æ–¹æ³•

``` java
1. åœ¨ Recorder Thread ä¸­åˆ›å»º Recorder ä¸ç›¸å…³çš„ Encoder
2. loop è¯»å– Recorder é‡Œé¢çš„ PCM dataï¼Œä¸æ–­åœ°å°† PCM å–‚å…¥ Encoderä¸­
3. å¤–éƒ¨åœæ­¢å½•éŸ³åï¼Œå°† run è¿™ä¸ª flag ç½®ä¸º false è·³å‡ºå¾ªç¯ï¼Œå¹¶ä¸” close ç›¸å…³ Encoder å¹¶ä¸”ä¿å­˜ä»–ä»¬çš„ç»“æœã€‚
4. release ç›¸å…³èµ„æºã€‚
```

åˆ›å»ºä¸€ä¸ªæ–°çš„MediaCodecå¯¹è±¡ç„¶åè°ƒç”¨configure()æ–¹æ³•å¯¹MediaCodecè¿›è¡Œé…ç½®

``` java
mMediaEncoder = MediaCodec.createEncoderByType("audio/mp4a-latm");
 
MediaFormat mediaFormat = new MediaFormat();
mediaFormat.setString(MediaFormat.KEY_MIME, "audio/mp4a-latm");
mediaFormat.setInteger(MediaFormat.KEY_AAC_PROFILE, MediaCodecInfo.CodecProfileLevel.AACObjectLC);
mediaFormat.setInteger(MediaFormat.KEY_BIT_RATE, 128000);
mediaFormat.setInteger(MediaFormat.KEY_CHANNEL_COUNT, 1);
mediaFormat.setInteger(MediaFormat.KEY_MAX_INPUT_SIZE, 1024 * 1024);
mediaFormat.setInteger(MediaFormat.KEY_SAMPLE_RATE, 44100);
// ç¬¬å››ä¸ªå‚æ•° ç¼–ç çš„æ—¶å€™æ˜¯MediaCodec.CONFIGURE_FLAG_ENCODE è§£ç çš„æ—¶å€™æ˜¯0
mMediaEncoder.configure(mediaFormat, null, null, MediaCodec.CONFIGURE_FLAG_ENCODE);
```

è°ƒç”¨MediaCodecçš„start()æ–¹æ³•ï¼Œæ­¤æ—¶MediaCodecå¤„äºExecutingçŠ¶æ€ï¼Œå¯ä»¥é€šè¿‡getInputBuffers()æ–¹æ³•å’ŒgetOutputBuffers()æ–¹æ³•è·å–ç¼“å­˜é˜Ÿåˆ—

``` java
// start()åè¿›å…¥æ‰§è¡ŒçŠ¶æ€ï¼Œæ‰èƒ½åšåç»­çš„æ“ä½œ
mMediaEncoder.start();
// è·å–è¾“å…¥ç¼“å­˜ï¼Œè¾“å‡ºç¼“å­˜
mAudioInputBuffers = mMediaEncoder.getInputBuffers();
mAudioOutputBuffers = mMediaEncoder.getOutputBuffers();
// getInput/OutputBuffers()å·²ç»è¢«åºŸå¼ƒï¼Œåº”é€šè¿‡dequeueOutputBuffer()è·å–idç„¶åä½¿ç”¨getInput/OutputBuffer(int)æ¥è·å–ç¼“å†²åŒºã€‚(è§ä¸‹æ–‡å®˜æ–¹ä¾‹å­)
```

è¿”å›çš„æ•´å‹å˜é‡ä¸ºè¯·æ±‚åˆ°çš„è¾“å…¥ç¼“å­˜çš„indexï¼Œé€šè¿‡getInputBuffers()å¾—åˆ°çš„æ˜¯è¾“å…¥ç¼“å­˜æ•°ç»„ï¼Œé€šè¿‡indexå’Œè¾“å…¥ç¼“å­˜æ•°ç»„å¯ä»¥å¾—åˆ°å½“å‰è¯·æ±‚çš„è¾“å…¥ç¼“å­˜ï¼Œåœ¨ä½¿ç”¨ä¹‹å‰è¦clearä¸€ä¸‹ï¼Œé¿å…ä¹‹å‰çš„ç¼“å­˜æ•°æ®å½±å“å½“å‰æ•°æ®

``` java
// dequeueInputBufferï¼ˆtimeï¼‰éœ€è¦ä¼ å…¥ä¸€ä¸ªæ—¶é—´å€¼ï¼Œ-1è¡¨ç¤ºä¸€ç›´ç­‰å¾…ï¼Œ0è¡¨ç¤ºä¸ç­‰å¾…æœ‰å¯èƒ½ä¼šä¸¢å¸§ï¼Œå…¶ä»–è¡¨ç¤ºç­‰å¾…å¤šå°‘æ¯«ç§’
int inputIndex = mMediaEncoder.dequeueInputBuffer(-1);
...
// è·å–è¾“å…¥ç¼“å­˜çš„index
ByteBuffer inputByteBuf = mAudioInputBuffers[inputIndex];
inputByteBuf.clear();
```

æŠŠæ•°æ®æ·»åŠ åˆ°è¾“å…¥ç¼“å­˜ä¸­ï¼Œå¹¶è°ƒç”¨queueInputBuffer()æŠŠç¼“å­˜æ•°æ®å…¥é˜Ÿ

``` java
// æ·»åŠ æ•°æ®
inputByteBuf.put(data);
// é™åˆ¶ByteBufferçš„è®¿é—®é•¿åº¦
inputByteBuf.limit(data.length);
// æŠŠè¾“å…¥ç¼“å­˜å¡å›å»ç»™MediaCodec
mMediaEncoder.queueInputBuffer(inputIndex, 0, data.length, 0, 0);
 
// mAudioEncoder.queueInputBuffer(inputBufIndex, 0, data.length, (1000000 * mEncodedSize / AUDIO_BYTE_PER_SAMPLE), 0);
// æœ‰äº›è®¾å¤‡ä¸è®¾ç½®å¥½presentationTimeUsä¼šä¸¢å¸§
// è¿™é‡Œçš„1000000æ˜¯æŠŠç§’å˜æˆå¾®ç§’ï¼ŒéŸ³é¢‘è¾“å‡ºçš„æ—¶é—´æˆ³æ˜¯å¾®ç§’ï¼Œè¾“å‡ºåˆ°surfaceçš„è§†é¢‘æ˜¯çº³ç§’ï¼Œæºç ä¸­æ˜¯è¿™ä¹ˆè¯´çš„ï¼š
// * @param presentationTimeUs The presentation timestamp in microseconds for this
// *                           buffer. This is normally the media time at which this
// *                           buffer should be presented (rendered). When using an output
// *                           surface, this will be propagated as the {@link
// *                           SurfaceTexture#getTimestamp timestamp} for the frame (after
// *                           conversion to nanoseconds).
```

è·å–è¾“å‡ºç¼“å­˜å’Œè·å–è¾“å…¥ç¼“å­˜ç±»ä¼¼ï¼Œé¦–å…ˆé€šè¿‡dequeueOutputBuffer(BufferInfo info, long timeoutUs)æ¥è¯·æ±‚ä¸€ä¸ªè¾“å‡ºç¼“å­˜ï¼Œè¿™é‡Œéœ€è¦ä¼ å…¥ä¸€ä¸ªBufferInfoå¯¹è±¡ï¼Œç”¨äºå­˜å‚¨ByteBufferçš„ä¿¡æ¯

``` java
// è·å–è¾“å‡ºç¼“å­˜çš„index
int outputIndex = mMediaEncoder.dequeueOutputBuffer(mBufferInfo, 0);
```

é€šè¿‡è¿”å›çš„indexå¾—åˆ°è¾“å‡ºç¼“å­˜ï¼Œå¹¶é€šè¿‡BufferInfoè·å–ByteBufferçš„ä¿¡æ¯ï¼Œæ³¨æ„ä¸€å®šè¦è°ƒç”¨releaseOutputBufferæ–¹æ³•

``` java
// è·å–è¾“å‡ºç¼“å­˜çš„index
int outputIndex = mMediaEncoder.dequeueOutputBuffer(mBufferInfo, 0);
while (outputIndex >= 0) {
    // è·å–ç¼“å­˜ä¿¡æ¯çš„é•¿åº¦
    int byteBufSize = mBufferInfo.size;
    ...
    // å¤„ç†æ•°æ®
    ...
    //é‡Šæ”¾
    mMediaEncoder.releaseOutputBuffer(outputIndex, false);
    outputIndex = mMediaEncoder.dequeueOutputBuffer(mBufferInfo, 0);
}
```

ä½¿ç”¨å®ŒMediaCodecåé‡Šæ”¾èµ„æº

``` java
mAudioEncoder.stop();
mAudioEncoder.release();
```

ä¸Šè¿°è¿‡ç¨‹çš„æ€»ç»“ä»£ç å¦‚ä¸‹ï¼šPCMæ•°æ®ç¼–ç ä¸ºAACæ•°æ®

``` java
public void init() {
    try {
        mMediaEncoder = MediaCodec.createEncoderByType("audio/mp4a-latm");
 
        MediaFormat mediaFormat = new MediaFormat();
        mediaFormat.setString(MediaFormat.KEY_MIME, "audio/mp4a-latm");
        mediaFormat.setInteger(MediaFormat.KEY_AAC_PROFILE, MediaCodecInfo.CodecProfileLevel.AACObjectLC);
        mediaFormat.setInteger(MediaFormat.KEY_BIT_RATE, 128000);
        mediaFormat.setInteger(MediaFormat.KEY_CHANNEL_COUNT, 1);
        mediaFormat.setInteger(MediaFormat.KEY_MAX_INPUT_SIZE, 1024 * 1024);
        mediaFormat.setInteger(MediaFormat.KEY_SAMPLE_RATE, 44100);
        // ç¬¬å››ä¸ªå‚æ•° ç¼–ç çš„æ—¶å€™æ˜¯MediaCodec.CONFIGURE_FLAG_ENCODE è§£ç çš„æ—¶å€™æ˜¯0
        mMediaEncoder.configure(mediaFormat, null, null, MediaCodec.CONFIGURE_FLAG_ENCODE);
        // start()åè¿›å…¥æ‰§è¡ŒçŠ¶æ€ï¼Œæ‰èƒ½åšåç»­çš„æ“ä½œ
        mMediaEncoder.start();
        // è·å–è¾“å…¥ç¼“å­˜ï¼Œè¾“å‡ºç¼“å­˜
        mAudioInputBuffers = mMediaEncoder.getInputBuffers();
        mAudioOutputBuffers = mMediaEncoder.getOutputBuffers();
    } catch (IOException e) {
        e.printStackTrace();
    }
}
 
public byte[] encodeData(byte[] data) {
    // dequeueInputBufferï¼ˆtimeï¼‰éœ€è¦ä¼ å…¥ä¸€ä¸ªæ—¶é—´å€¼ï¼Œ-1è¡¨ç¤ºä¸€ç›´ç­‰å¾…ï¼Œ0è¡¨ç¤ºä¸ç­‰å¾…æœ‰å¯èƒ½ä¼šä¸¢å¸§ï¼Œå…¶ä»–è¡¨ç¤ºç­‰å¾…å¤šå°‘æ¯«ç§’
    int inputIndex = mMediaEncoder.dequeueInputBuffer(-1);
    // è·å–è¾“å…¥ç¼“å­˜çš„index
    if (inputIndex >= 0) {
        ByteBuffer inputByteBuf = mAudioInputBuffers[inputIndex];
        inputByteBuf.clear();
        // æ·»åŠ æ•°æ®
        inputByteBuf.put(data);
        // é™åˆ¶ByteBufferçš„è®¿é—®é•¿åº¦
        inputByteBuf.limit(data.length);
        // æŠŠè¾“å…¥ç¼“å­˜å¡å›å»ç»™MediaCodec
        mMediaEncoder.queueInputBuffer(inputIndex, 0, data.length, 0, 0);
    }
 
    // è·å–è¾“å‡ºç¼“å­˜çš„index
    int outputIndex = mMediaEncoder.dequeueOutputBuffer(mBufferInfo, 0);
    while (outputIndex >= 0) {
        // è·å–ç¼“å­˜ä¿¡æ¯çš„é•¿åº¦
        int byteBufSize = mBufferInfo.size;
        // æ·»åŠ ADTSå¤´éƒ¨åçš„é•¿åº¦
        int bytePacketSize = byteBufSize + 7;
 
        ByteBuffer outPutBuf = mAudioOutputBuffers[outputIndex];
        outPutBuf.position(mBufferInfo.offset);
        outPutBuf.limit(mBufferInfo.offset + mBufferInfo.size);
 
        byte[] targetByte = new byte[bytePacketSize];
        //æ·»åŠ ADTSå¤´éƒ¨
        addADTStoPacket(targetByte, bytePacketSize);
        /*
        getï¼ˆbyte[] dst,int offset,int lengthï¼‰:ByteBufferä»positionä½ç½®å¼€å§‹è¯»ï¼Œè¯»å–lengthä¸ªbyteï¼Œå¹¶å†™å…¥dstä¸‹
        æ ‡ä»offsetåˆ°offset + lengthçš„åŒºåŸŸ
         */
        outPutBuf.get(targetByte, 7, byteBufSize);
 
        outPutBuf.position(mBufferInfo.offset);
 
        try {
            fileOutputStream.write(targetByte);
        } catch (IOException e) {
            e.printStackTrace();
        }
        //é‡Šæ”¾
        mMediaEncoder.releaseOutputBuffer(outputIndex, false);
        outputIndex = mMediaEncoder.dequeueOutputBuffer(mBufferInfo, 0);
    }
    return data;
}
 
/**
 * ç»™ç¼–ç å‡ºçš„aacè£¸æµæ·»åŠ adtså¤´å­—æ®µ
 * @param packet    è¦ç©ºå‡ºå‰7ä¸ªå­—èŠ‚ï¼Œå¦åˆ™ä¼šæä¹±æ•°æ®
 * @param packetLen
 */
private void addADTStoPacket(byte[] packet, int packetLen) {
    int profile = 2;  // AAC LC
    int freqIdx = 4;  // 44.1KHz
    int chanCfg = 1;  // SCE
    packet[0] = (byte) 0xFF;
    packet[1] = (byte) 0xF9;
    packet[2] = (byte) (((profile - 1) << 6) + (freqIdx << 2) + (chanCfg >> 2));
    packet[3] = (byte) (((chanCfg & 3) << 6) + (packetLen >> 11));
    packet[4] = (byte) ((packetLen & 0x7FF) >> 3);
    packet[5] = (byte) (((packetLen & 7) << 5) + 0x1F);
    packet[6] = (byte) 0xFC;
}
```

é™„å¸¦è´´ä¸Šä¸€æ®µå®˜æ–¹æä¾›çš„ä»£ç æ€è·¯ï¼ˆå­¦ä¹ æ€è·¯ï¼‰ï¼šå®˜æ–¹ç»™å‡ºçš„ä¸€æ®µåŒæ­¥å…¸å‹ä»£ç 

``` java
MediaCodec codec = MediaCodec.createByCodecName(name);
codec.configure(format, â€¦);
MediaFormat outputFormat = codec.getOutputFormat(); // option B
codec.start();
for (;;) {
  int inputBufferId = codec.dequeueInputBuffer(timeoutUs);
  if (inputBufferId >= 0) {
    ByteBuffer inputBuffer = codec.getInputBuffer(â€¦);
    // fill inputBuffer with valid data
    â€¦
    codec.queueInputBuffer(inputBufferId, â€¦);
  }
  int outputBufferId = codec.dequeueOutputBuffer(â€¦);
  if (outputBufferId >= 0) {
    ByteBuffer outputBuffer = codec.getOutputBuffer(outputBufferId);
    MediaFormat bufferFormat = codec.getOutputFormat(outputBufferId); // option A
    // bufferFormat is identical to outputFormat
    // outputBuffer is ready to be processed or rendered.
    â€¦
    codec.releaseOutputBuffer(outputBufferId, â€¦);
  } else if (outputBufferId == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) {
    // Subsequent data will conform to new format.
    // Can ignore if using getOutputFormat(outputBufferId)
    outputFormat = codec.getOutputFormat(); // option B
  }
}
codec.stop();
codec.release();
```

***

#### MediaCodecç¼–ç ä¾‹å­ï¼ˆå¼‚æ­¥ï¼‰

ä½¿ç”¨AudioRecordå½•åˆ¶éŸ³é¢‘ï¼ŒMediaCodecç¼–ç ä¸ºAAC

è®¾ç½®å›è°ƒæ–¹æ³•å¿…é¡»åœ¨MediaCodecåˆ›å»ºä¹‹åï¼Œå¹¶ä¸”åœ¨configureæ–¹æ³•ä¹‹å‰ã€‚

å…¶ä¸­indexæ˜¯æŒ‡å‘ç¼“å†²åŒºçš„BufferIdï¼Œåˆ©ç”¨è¿™ä¸ªindexç”¨æˆ·å¯ä»¥è·å¾—ç¼“å†²åŒºï¼›formatæ˜¯å˜åŒ–åçš„Mediaformatã€‚

``` java
// å½“inputbufferå¯ç”¨æ—¶å›è°ƒæ­¤æ–¹æ³•
void onInputBufferAvailable(MediaCodec codec, int index)
 
// å½“outputbufferå¯ç”¨æ—¶å›è°ƒæ­¤æ–¹æ³•
void onOutputBufferAvailable(MediaCodec codec, int index, MediaCodec.BufferInfo info)
 
// å½“è¾“å‡ºæ ¼å¼å˜åŒ–æ—¶å›è°ƒæ­¤æ–¹æ³•
void onOutputFormatChanged(MediaCodec codec, MediaFormat format)
 
// å‘ç”Ÿé”™è¯¯æ—¶å›è°ƒæ­¤æ–¹æ³•
void onError(MediaCodec codec, MediaCodec.CodecException e)
```

åŸºäºåŒæ­¥çš„æ–¹æ³•åšå¯¹åº”ä¿®æ”¹ï¼Œå¦‚ä¸‹ç»™å‡ºå®˜æ–¹ç¤ºä¾‹ï¼šå®˜æ–¹ç»™å‡ºçš„ä¸€æ®µå¼‚æ­¥å…¸å‹ä»£ç 

``` java
MediaCodec codec = MediaCodec.createByCodecName(name);
MediaFormat mOutputFormat; // member variable
codec.setCallback(new MediaCodec.Callback() {
   @Override
   void onInputBufferAvailable(MediaCodec mc, int inputBufferId) {
     ByteBuffer inputBuffer = codec.getInputBuffer(inputBufferId);
     // fill inputBuffer with valid data
     â€¦
     codec.queueInputBuffer(inputBufferId, â€¦);
   }
 
   @Override
   void onOutputBufferAvailable(MediaCodec mc, int outputBufferId, â€¦) {
     ByteBuffer outputBuffer = codec.getOutputBuffer(outputBufferId);
     MediaFormat bufferFormat = codec.getOutputFormat(outputBufferId); // option A
     // bufferFormat is equivalent to mOutputFormat
     // outputBuffer is ready to be processed or rendered.
     â€¦
     codec.releaseOutputBuffer(outputBufferId, â€¦);
   }
 
   @Override
   void onOutputFormatChanged(MediaCodec mc, MediaFormat format) {
     // Subsequent data will conform to new format.
     // Can ignore if using getOutputFormat(outputBufferId)
     mOutputFormat = format; // option B
   }
 
   @Override
   void onError(â€¦) {
     â€¦
   }
});
codec.configure(format, â€¦);
mOutputFormat = codec.getOutputFormat(); // option B
codec.start();
// wait for processing to complete
codec.stop();
codec.release();
```

***

#### MediaCodecè§£ç ä¾‹å­

ç¡¬è§£ç AACéŸ³é¢‘æ–‡ä»¶å¹¶æ’­æ”¾

åˆå§‹åŒ–ç»“æŸåï¼Œè°ƒç”¨play()ä¼ å…¥éŸ³é¢‘æ–‡ä»¶å³å¯

é…ç½®æ’­æ”¾å™¨initAudioTrack()

``` java
private void initAudioTrack() {
    // é…ç½®æ’­æ”¾å™¨
    int streamType = AudioManager.STREAM_MUSIC;
    int sampleRate = 44100;
    int channelConfig = AudioFormat.CHANNEL_OUT_MONO;
    int audioFormat = AudioFormat.ENCODING_PCM_16BIT;
    int mode = AudioTrack.MODE_STREAM;
    int minBufferSize = AudioTrack.getMinBufferSize(sampleRate, channelConfig, audioFormat);
    mAudioTrack = new AudioTrack(streamType, sampleRate, channelConfig, audioFormat,
            Math.max(minBufferSize, 2048), mode);
}
```

é…ç½®è§£ç å™¨initDecoder()

``` java
private void initDecoder() {
    try {
        // éœ€è¦è§£ç æ•°æ®çš„ç±»å‹
        String mine = "audio/mp4a-latm";
        // åˆå§‹åŒ–è§£ç å™¨
        mDecoder = MediaCodec.createDecoderByType(mine);
        // MediaFormatç”¨äºæè¿°éŸ³è§†é¢‘æ•°æ®çš„ç›¸å…³å‚æ•°
        MediaFormat mediaFormat = new MediaFormat();
        // æ•°æ®ç±»å‹
        mediaFormat.setString(MediaFormat.KEY_MIME, mine);
        // å£°é“ä¸ªæ•°
        mediaFormat.setInteger(MediaFormat.KEY_CHANNEL_COUNT, 2);
        // é‡‡æ ·ç‡
        mediaFormat.setInteger(MediaFormat.KEY_SAMPLE_RATE, 48000);
        // æ¯”ç‰¹ç‡
        mediaFormat.setInteger(MediaFormat.KEY_BIT_RATE, 128000);
        // ç”¨æ¥æ ‡è®°AACæ˜¯å¦æœ‰adtså¤´ï¼Œ1->æœ‰
        mediaFormat.setInteger(MediaFormat.KEY_IS_ADTS, 1);
        // ç”¨æ¥æ ‡è®°aacçš„ç±»å‹
        mediaFormat.setInteger(MediaFormat.KEY_AAC_PROFILE, MediaCodecInfo.CodecProfileLevel.AACObjectLC);
        byte[] data = new byte[]{(byte) 0x11, (byte) 0x90};
        ByteBuffer csd_0 = ByteBuffer.wrap(data);
        mediaFormat.setByteBuffer("csd-0", csd_0);
        // è§£ç å™¨é…ç½®
        mDecoder.configure(mediaFormat, null, null, 0);
 
        mDecoder.start();
        // è¾“å…¥ByteBuffer
        mCodecInputBuffers = mDecoder.getInputBuffers();
        // è¾“å‡ºByteBuffer
        mCodecOutputBuffers = mDecoder.getOutputBuffers();
    } catch (IOException e) {
        e.printStackTrace();
    }
}
```

ä¼ å…¥æ–‡ä»¶å³å¯æ’­æ”¾aacéŸ³é¢‘play()

``` java
public void play(File audioRecordFile) {
    // è¿™ä¸ªå€¼ç”¨äºæ‰¾åˆ°ç¬¬ä¸€ä¸ªå¸§å¤´åï¼Œç»§ç»­å¯»æ‰¾ç¬¬äºŒä¸ªå¸§å¤´ï¼Œå¦‚æœè§£ç å¤±è´¥å¯ä»¥å°è¯•ç¼©å°è¿™ä¸ªå€¼
    int FRAME_MIN_LEN = 50;
    // ä¸€èˆ¬AACå¸§å¤§å°ä¸è¶…è¿‡200k,å¦‚æœè§£ç å¤±è´¥å¯ä»¥å°è¯•å¢å¤§è¿™ä¸ªå€¼
    int FRAME_MAX_LEN = 100 * 1024;
    // ä»æ–‡ä»¶æµè¯»æ•°æ®
    FileInputStream fis = null;
    byte[] mBuffer = new byte[2048];
    try {
        // å¾ªç¯è¯»æ•°æ®ï¼Œå†™åˆ°æ’­æ”¾å™¨å»æ’­æ”¾
        fis = new FileInputStream(audioRecordFile);
        Log.d(TAG, audioRecordFile.toString());
        // ä¿å­˜å®Œæ•´æ•°æ®å¸§
        byte[] frame = new byte[FRAME_MAX_LEN];
        // å½“å‰å¸§é•¿åº¦
        int frameLen = 0;
        // æ¯æ¬¡ä»æ–‡ä»¶è¯»å–çš„æ•°æ®
        byte[] readData = new byte[10 * 1024];
        // å¾ªç¯è¯»æ•°æ®ï¼Œå†™åˆ°æ’­æ”¾å™¨å»æ’­æ”¾ åªè¦æ²¡è¯»å®Œï¼Œå¾ªç¯æ’­æ”¾
        mAudioTrack.play();
        int readLen;
        while ((readLen = fis.read(mBuffer)) != -1) {
            // å½“å‰é•¿åº¦å°äºæœ€å¤§å€¼
            if (frameLen + readLen < FRAME_MAX_LEN) {
                // å°†readDataæ‹·è´åˆ°frame
                System.arraycopy(readData, 0, frame, frameLen, readLen);
                // ä¿®æ”¹frameLen
                frameLen += readLen;
                // å¯»æ‰¾ç¬¬ä¸€ä¸ªå¸§å¤´
                int headFirstIndex = findHead(frame, 0, frameLen);
                while (headFirstIndex >= 0 && isHead(frame, headFirstIndex)) {
                    // å¯»æ‰¾ç¬¬äºŒä¸ªå¸§å¤´
                    int headSecondIndex = findHead(frame, headFirstIndex + FRAME_MIN_LEN, frameLen);
                    // å¦‚æœç¬¬äºŒä¸ªå¸§å¤´å­˜åœ¨ï¼Œåˆ™ä¸¤ä¸ªå¸§å¤´ä¹‹é—´çš„å°±æ˜¯ä¸€å¸§å®Œæ•´çš„æ•°æ®
                    if (headSecondIndex > 0 && isHead(frame, headSecondIndex)) {
                        // è§†é¢‘è§£ç 
                        decodeData(frame, headFirstIndex, headSecondIndex - headFirstIndex);
                        // æˆªå–headSecondIndexä¹‹ååˆ°frameçš„æœ‰æ•ˆæ•°æ®,å¹¶æ”¾åˆ°frameæœ€å‰é¢
                        byte[] temp = Arrays.copyOfRange(frame, headSecondIndex, frameLen);
                        System.arraycopy(temp, 0, frame, 0, temp.length);
                        // ä¿®æ”¹frameLençš„å€¼
                        frameLen = temp.length;
                        // ç»§ç»­å¯»æ‰¾æ•°æ®å¸§
                        headFirstIndex = findHead(frame, 0, frameLen);
                    } else {
                        // æ‰¾ä¸åˆ°ç¬¬äºŒä¸ªå¸§å¤´
                        headFirstIndex = -1;
                    }
                }
            } else {
                //å¦‚æœé•¿åº¦è¶…è¿‡æœ€å¤§å€¼ï¼ŒframeLenç½®0
                frameLen = 0;
            }
        }
        Log.d(TAG, "æ’­æ”¾å®Œæ¯•ï¼");
    } catch (Exception e) {
        e.printStackTrace();
    } finally {
        closeInputStream(fis);
        // æ’­æ”¾å™¨é‡Šæ”¾
        resetQuietly(mAudioTrack);
    }
}
```

play()ä¸­çš„aacè§£ç +æ’­æ”¾å‡½æ•°decodeData()

``` java
/**
 * aacè§£ç +æ’­æ”¾
 */
private void decodeData(byte[] data, int offset, int length) {
    int inputIndex = mDecoder.dequeueInputBuffer(-1);
    if (inputIndex >= 0) {
        // è·å–å½“å‰çš„ByteBuffer
        ByteBuffer inputByteBuf = mCodecInputBuffers[inputIndex];
        // æ¸…ç©ºByteBuffer
        inputByteBuf.clear();
        // å¡«å……æ•°æ®
        inputByteBuf.put(data, offset, length);
        // å°†æŒ‡å®šindexçš„input bufferæäº¤ç»™è§£ç å™¨
        mDecoder.queueInputBuffer(inputIndex, 0, length, 0, 0);
    }
    // ç¼–è§£ç å™¨ç¼“å†²åŒº
    MediaCodec.BufferInfo info = new MediaCodec.BufferInfo();
    int outputBufferIndex = mDecoder.dequeueOutputBuffer(info, -1);
    ByteBuffer outputBuffer;
    while (outputBufferIndex >= 0) {
        // è·å–è§£ç åçš„ByteBuffer
        outputBuffer = mCodecOutputBuffers[outputBufferIndex];
        // ç”¨æ¥ä¿å­˜è§£ç åçš„æ•°æ®
        byte[] outData = new byte[info.size];
        outputBuffer.get(outData);
        // æ¸…ç©ºç¼“å­˜
        outputBuffer.clear();
        // æ’­æ”¾è§£ç åçš„æ•°æ®
        mAudioTrack.write(outData, 0, info.size);
        // é‡Šæ”¾å·²ç»è§£ç çš„buffer
        mDecoder.releaseOutputBuffer(outputBufferIndex, false);
        // è§£ç æœªè§£å®Œçš„æ•°æ®
        outputBufferIndex = mDecoder.dequeueOutputBuffer(info, -1);
    }
}
```

play()ä¸­çš„æ‰¾ç¼“å­˜ä¸­aacå¸§å¤´èµ·å§‹ä½ç½®findHead()

``` java
/**
 * å¯»æ‰¾æŒ‡å®šbufferä¸­AACå¸§å¤´çš„å¼€å§‹ä½ç½®
 *
 * @param startIndex å¼€å§‹çš„ä½ç½®
 * @param data       æ•°æ®
 * @param max        éœ€è¦æ£€æµ‹çš„æœ€å¤§å€¼
 * @return
 */
private int findHead(byte[] data, int startIndex, int max) {
    int i;
    for (i = startIndex; i <= max; i++) {
        // å‘ç°å¸§å¤´
        if (isHead(data, i))
            break;
    }
    // æ£€æµ‹åˆ°æœ€å¤§å€¼ï¼Œæœªå‘ç°å¸§å¤´
    if (i == max) {
        i = -1;
    }
    return i;
}
```

play()ä¸­çš„åˆ¤æ–­aacå¸§å¤´æ–¹æ³•isHead()

``` java
/**
 * åˆ¤æ–­aacå¸§å¤´
 */
private boolean isHead(byte[] data, int offset) {
    boolean result = false;
    if (data[offset] == (byte) 0xFF && data[offset + 1] == (byte) 0xF1
            && data[offset + 3] == (byte) 0x80) {
        result = true;
    }
    return result;
}
```
