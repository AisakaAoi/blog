---
title: Android-éŸ³è§†é¢‘-è§†é¢‘å¼€å‘-ï¼ˆå››ï¼‰è§†é¢‘ç¼–è§£ç 
categories:
  - ğŸŒ™é€¢å‚æ‚è°ˆä¸æ¬è¿
  - â­ä¸€äº›æŠ€æœ¯
abbrlink: 1a455a10
date: 2021-10-25 11:18:36
tags:
---

### ç®€ä»‹

åœ¨å­¦ä¹ äº†Android éŸ³è§†é¢‘çš„åŸºæœ¬çš„ç›¸å…³çŸ¥è¯†ï¼Œå¹¶æ•´ç†äº†ç›¸å…³çš„APIä¹‹åï¼Œåº”è¯¥å¯¹åŸºæœ¬çš„éŸ³è§†é¢‘æœ‰ä¸€å®šçš„è½®å»“äº†ã€‚

ä¸‹é¢æ˜¯ä¸€ä¸ªAndroidéŸ³è§†é¢‘ä¸­ç›¸å½“é‡è¦çš„å‡ ä¸ªAPIï¼š**MediaCodec**ï¼ˆéŸ³è§†é¢‘ç¼–è§£ç ï¼‰ã€**MediaExtractor**ï¼ˆéŸ³è§†é¢‘è§£å°è£…ï¼‰ã€**MediaMuxer**ï¼ˆéŸ³è§†é¢‘å°è£…ï¼‰ã€‚

å­¦ä¹ è¿™ä¸ªAPIçš„æ—¶å€™ï¼Œä¸»è¦çš„æ–¹å‘ä¸ºï¼š

- å­¦ä¹  MediaCodec APIï¼Œå®ŒæˆéŸ³é¢‘ AAC ç¡¬ç¼–ã€ç¡¬è§£
- å­¦ä¹  MediaCodec APIï¼Œå®Œæˆè§†é¢‘ H.264 çš„ç¡¬ç¼–ã€ç¡¬è§£

***

<!--more-->

### MediaCodec

#### MediaCodec ä»‹ç»

MediaCodecç±»å¯ä»¥ç”¨äºä½¿ç”¨ä¸€äº›åŸºæœ¬çš„å¤šåª’ä½“ç¼–è§£ç å™¨ï¼ˆéŸ³è§†é¢‘ç¼–è§£ç ç»„ä»¶ï¼‰ï¼Œå®ƒæ˜¯AndroidåŸºæœ¬çš„å¤šåª’ä½“æ”¯æŒåŸºç¡€æ¶æ„çš„ä¸€éƒ¨åˆ†é€šå¸¸å’Œ**MediaExtractor**ï¼ˆè§£å°è£…éŸ³è§†é¢‘ï¼‰, **MediaSync**ï¼ˆéŸ³è§†é¢‘åŒæ­¥ï¼‰, **MediaMuxer**ï¼ˆå°è£…éŸ³è§†é¢‘ï¼‰, **MediaCrypto**ï¼ˆè§£ç åŠ å¯†çš„åª’ä½“æ•°æ®ï¼‰, **MediaDrm**ï¼ˆè§£å¯†DRMï¼‰, Image, Surface, AudioTrack ä¸€èµ·ä½¿ç”¨ã€‚

ä¸€ä¸ª**ç¼–è§£ç å™¨**å¯ä»¥**å¤„ç†è¾“å…¥**çš„æ•°æ®æ¥**äº§ç”Ÿè¾“å‡º**çš„æ•°æ®ï¼Œç¼–è§£ç å™¨ä½¿ç”¨**ä¸€ç»„è¾“å…¥å’Œè¾“å‡ºç¼“å†²å™¨**æ¥**å¼‚æ­¥**å¤„ç†æ•°æ®ã€‚ä½ å¯ä»¥**åˆ›å»º**ä¸€ä¸ªç©ºçš„è¾“å…¥ç¼“å†²åŒºï¼Œ**å¡«å……**æ•°æ®å**å‘é€**åˆ°ç¼–è§£ç å™¨è¿›è¡Œå¤„ç†ã€‚ç¼–è§£ç å™¨ä½¿ç”¨è¾“å…¥çš„æ•°æ®è¿›è¡Œ**è½¬æ¢**ï¼Œç„¶å**è¾“å‡º**åˆ°ä¸€ä¸ªç©ºçš„è¾“å‡ºç¼“å†²åŒºã€‚æœ€åä½ **è·å–**åˆ°è¾“å‡ºç¼“å†²åŒºçš„æ•°æ®ï¼Œæ¶ˆè€—æ‰é‡Œé¢çš„æ•°æ®ï¼Œ**é‡Šæ”¾**å›ç¼–è§£ç å™¨ã€‚å¦‚æœåç»­è¿˜æœ‰æ•°æ®éœ€è¦ç»§ç»­å¤„ç†ï¼Œç¼–è§£ç å™¨å°±ä¼šé‡å¤è¿™äº›æ“ä½œã€‚è¾“å‡ºæµç¨‹å¦‚ä¸‹ï¼š

{% asset_img 1.webp %}

ç¼–è§£ç å™¨çš„ç”Ÿå‘½å‘¨æœŸï¼š

ä¸»è¦çš„ç”Ÿå‘½å‘¨æœŸä¸ºï¼šStoppedã€Executingã€Releasedã€‚

- Stoppedçš„çŠ¶æ€ä¸‹ä¹Ÿåˆ†ä¸ºä¸‰ç§å­çŠ¶æ€ï¼šUninitializedã€Configuredã€Errorã€‚
- Executingçš„çŠ¶æ€ä¸‹ä¹Ÿåˆ†ä¸ºä¸‰ç§å­çŠ¶æ€ï¼šFlushed, Runningã€End-of-Streamã€‚

ç”Ÿå‘½å‘¨æœŸå›¾ï¼šåŒæ­¥ï¼ˆå·¦ï¼‰ä¸å¼‚æ­¥ï¼ˆå³ï¼‰

{% asset_img 2.webp %}

{% asset_img 3.webp %}

#### MediaCodec API è¯´æ˜

MediaCodecå¯ä»¥å¤„ç†å…·ä½“çš„è§†é¢‘æµï¼Œä¸»è¦æœ‰è¿™å‡ ä¸ªæ–¹æ³•ï¼š

- getInputBuffersï¼šè·å–éœ€è¦ç¼–ç æ•°æ®çš„è¾“å…¥æµé˜Ÿåˆ—ï¼Œè¿”å›çš„æ˜¯ä¸€ä¸ªByteBufferæ•°ç»„
- queueInputBufferï¼šè¾“å…¥æµå…¥é˜Ÿåˆ—
- dequeueInputBufferï¼šä»è¾“å…¥æµé˜Ÿåˆ—ä¸­å–æ•°æ®è¿›è¡Œç¼–ç æ“ä½œ
- getOutputBuffersï¼šè·å–ç¼–è§£ç ä¹‹åçš„æ•°æ®è¾“å‡ºæµé˜Ÿåˆ—ï¼Œè¿”å›çš„æ˜¯ä¸€ä¸ªByteBufferæ•°ç»„
- dequeueOutputBufferï¼šä»è¾“å‡ºé˜Ÿåˆ—ä¸­å–å‡ºç¼–ç æ“ä½œä¹‹åçš„æ•°æ®
- releaseOutputBufferï¼šå¤„ç†å®Œæˆï¼Œé‡Šæ”¾ByteBufferæ•°æ®

#### MediaCodec æµæ§

**æµæ§åŸºæœ¬æ¦‚å¿µï¼š**

æµæ§å°±æ˜¯æµé‡æ§åˆ¶ã€‚æ¶‰åŠåˆ°äº† TCP å’Œè§†é¢‘ç¼–ç ï¼šå¯¹ TCP æ¥è¯´å°±æ˜¯æ§åˆ¶å•ä½æ—¶é—´å†…å‘é€æ•°æ®åŒ…çš„æ•°æ®é‡ï¼Œå¯¹ç¼–ç æ¥è¯´å°±æ˜¯æ§åˆ¶å•ä½æ—¶é—´å†…è¾“å‡ºæ•°æ®çš„æ•°æ®é‡ã€‚

- TCP çš„é™åˆ¶æ¡ä»¶æ˜¯ç½‘ç»œå¸¦å®½ï¼Œæµæ§å°±æ˜¯åœ¨é¿å…é€ æˆæˆ–è€…åŠ å‰§ç½‘ç»œæ‹¥å¡çš„å‰æä¸‹ï¼Œå°½å¯èƒ½åˆ©ç”¨ç½‘ç»œå¸¦å®½ã€‚å¸¦å®½å¤Ÿã€ç½‘ç»œå¥½ï¼Œæˆ‘ä»¬å°±åŠ å¿«é€Ÿåº¦å‘é€æ•°æ®åŒ…ï¼Œå‡ºç°äº†å»¶è¿Ÿå¢å¤§ã€ä¸¢åŒ…ä¹‹åï¼Œå°±æ”¾æ…¢å‘åŒ…çš„é€Ÿåº¦ï¼ˆå› ä¸ºç»§ç»­é«˜é€Ÿå‘åŒ…ï¼Œå¯èƒ½ä¼šåŠ å‰§ç½‘ç»œæ‹¥å¡ï¼Œåè€Œå‘å¾—æ›´æ…¢ï¼‰ã€‚
è§†é¢‘ç¼–ç çš„é™åˆ¶æ¡ä»¶æœ€åˆæ˜¯è§£ç å™¨çš„èƒ½åŠ›ï¼Œç ç‡å¤ªé«˜å°±ä¼šæ— æ³•è§£ç ï¼Œåæ¥éšç€ codec çš„å‘å±•ï¼Œè§£ç èƒ½åŠ›ä¸å†æ˜¯ç“¶é¢ˆï¼Œé™åˆ¶æ¡ä»¶å˜æˆäº†ä¼ è¾“å¸¦å®½/æ–‡ä»¶å¤§å°ï¼Œæˆ‘ä»¬å¸Œæœ›åœ¨æ§åˆ¶æ•°æ®é‡çš„å‰æä¸‹ï¼Œç”»é¢è´¨é‡å°½å¯èƒ½é«˜ã€‚
- æ— è®ºæ˜¯è¦å‘é€çš„ TCP æ•°æ®åŒ…ï¼Œè¿˜æ˜¯è¦ç¼–ç çš„å›¾åƒï¼Œéƒ½å¯èƒ½å‡ºç°â€œå°–å³°â€ï¼Œä¹Ÿå°±æ˜¯çŸ­æ—¶é—´å†…å‡ºç°è¾ƒå¤§çš„æ•°æ®é‡ã€‚TCP é¢å¯¹å°–å³°ï¼Œå¯ä»¥é€‰æ‹©ä¸ä¸ºæ‰€åŠ¨ï¼ˆå°¤å…¶æ˜¯ç½‘ç»œå·²ç»æ‹¥å¡çš„æ—¶å€™ï¼‰ï¼Œè¿™æ²¡æœ‰å¤ªå¤§çš„é—®é¢˜ï¼Œä½†å¦‚æœè§†é¢‘ç¼–ç ä¹Ÿå¯¹å°–å³°ä¸ä¸ºæ‰€åŠ¨ï¼Œé‚£å›¾åƒè´¨é‡å°±ä¼šå¤§æ‰“æŠ˜æ‰£äº†ã€‚å¦‚æœæœ‰å‡ å¸§æ•°æ®é‡ç‰¹åˆ«å¤§ï¼Œä½†ä»è¦æŠŠç ç‡æ§åˆ¶åœ¨åŸæ¥çš„æ°´å¹³ï¼Œé‚£åŠ¿å¿…è¦æŸå¤±æ›´å¤šçš„ä¿¡æ¯ï¼Œå› æ­¤å›¾åƒå¤±çœŸå°±ä¼šæ›´ä¸¥é‡ã€‚

**Android ç¡¬ç¼–ç æµæ§ï¼š**

MediaCodec æµæ§ç›¸å…³çš„æ¥å£å¹¶ä¸å¤šï¼Œä¸€æ˜¯é…ç½®æ—¶è®¾ç½®ç›®æ ‡ç ç‡å’Œç ç‡æ§åˆ¶æ¨¡å¼ï¼ŒäºŒæ˜¯åŠ¨æ€è°ƒæ•´ç›®æ ‡ç ç‡(Android 19 ç‰ˆæœ¬ä»¥ä¸Š)ã€‚

é…ç½®æ—¶æŒ‡å®šç›®æ ‡ç ç‡å’Œç ç‡æ§åˆ¶æ¨¡å¼

``` java
mediaFormat.setInteger(MediaFormat.KEY_BIT_RATE, bitRate);
mediaFormat.setInteger(MediaFormat.KEY_BITRATE_MODE, MediaCodecInfo.EncoderCapabilities.BITRATE_MODE_VBR);
mVideoCodec.configure(mediaFormat, null, null, MediaCodec.CONFIGURE_FLAG_ENCODE);
```

ç ç‡æ§åˆ¶æ¨¡å¼æœ‰ä¸‰ç§ï¼š

- CQ  è¡¨ç¤ºå®Œå…¨ä¸æ§åˆ¶ç ç‡ï¼Œå°½æœ€å¤§å¯èƒ½ä¿è¯å›¾åƒè´¨é‡ï¼›
- CBR è¡¨ç¤ºç¼–ç å™¨ä¼šå°½é‡æŠŠè¾“å‡ºç ç‡æ§åˆ¶ä¸ºè®¾å®šå€¼ï¼Œå³æˆ‘ä»¬å‰é¢æåˆ°çš„â€œä¸ä¸ºæ‰€åŠ¨â€ï¼›
- VBR è¡¨ç¤ºç¼–ç å™¨ä¼šæ ¹æ®å›¾åƒå†…å®¹çš„å¤æ‚åº¦ï¼ˆå®é™…ä¸Šæ˜¯å¸§é—´å˜åŒ–é‡çš„å¤§å°ï¼‰æ¥åŠ¨æ€è°ƒæ•´è¾“å‡ºç ç‡ï¼Œå›¾åƒå¤æ‚åˆ™ç ç‡é«˜ï¼Œå›¾åƒç®€å•åˆ™ç ç‡ä½ï¼›

**Android æµæ§ç­–ç•¥é€‰æ‹©ï¼š**

- è´¨é‡è¦æ±‚é«˜ã€ä¸åœ¨ä¹å¸¦å®½ã€è§£ç å™¨æ”¯æŒç ç‡å‰§çƒˆæ³¢åŠ¨çš„æƒ…å†µä¸‹ï¼Œå¯ä»¥é€‰æ‹© CQ ç ç‡æ§åˆ¶ç­–ç•¥ã€‚
- VBR è¾“å‡ºç ç‡ä¼šåœ¨ä¸€å®šèŒƒå›´å†…æ³¢åŠ¨ï¼Œå¯¹äºå°å¹…æ™ƒåŠ¨ï¼Œæ–¹å—æ•ˆåº”ä¼šæœ‰æ‰€æ”¹å–„ï¼Œä½†å¯¹å‰§çƒˆæ™ƒåŠ¨ä»æ— èƒ½ä¸ºåŠ›ï¼›è¿ç»­è°ƒä½ç ç‡åˆ™ä¼šå¯¼è‡´ç ç‡æ€¥å‰§ä¸‹é™ï¼Œå¦‚æœæ— æ³•æ¥å—è¿™ä¸ªé—®é¢˜ï¼Œé‚£ VBR å°±ä¸æ˜¯å¥½çš„é€‰æ‹©ã€‚
- CBR çš„ä¼˜ç‚¹æ˜¯ç¨³å®šå¯æ§ï¼Œè¿™æ ·å¯¹å®æ—¶æ€§çš„ä¿è¯æœ‰å¸®åŠ©ã€‚æ‰€ä»¥ WebRTC å¼€å‘ä¸­ä¸€èˆ¬ä½¿ç”¨çš„æ˜¯CBRã€‚

#### MediaCodec ä½¿ç”¨

MediaCodecå¸¸ç”¨æ–¹æ³•

``` java
createEncoderByTypeï¼ˆ@NonNul String typeï¼‰ï¼šé™æ€æ„é€ æ–¹æ³•ï¼Œtypeä¸ºæŒ‡å®šçš„éŸ³è§†é¢‘æ ¼å¼ï¼Œåˆ›å»ºæŒ‡å®šæ ¼å¼çš„ç¼–ç å™¨
createDecoderByType(@NonNull String type)ï¼šé™æ€æ„é€ æ–¹æ³•ï¼Œtypeä¸ºæŒ‡å®šçš„éŸ³è§†é¢‘æ ¼å¼ï¼Œåˆ›å»ºæŒ‡å®šæ ¼å¼çš„è§£ç å™¨
  
// MediaCodecçš„è®¾ç½®
configure(
       @Nullable MediaFormat format,    // ç»‘å®šç¼–è§£ç çš„åª’ä½“æ ¼å¼
       @Nullable Surface surface,       // ç»‘å®šsurfaceï¼Œå¯ä»¥ç›´æ¥å®Œæˆæ•°æ®çš„æ¸²æŸ“
       @Nullable MediaCrypto crypto,    // åŠ å¯†ç®—æ³•
       @ConfigureFlag int flags)        // åŠ å¯†çš„æ ¼å¼ï¼Œå¦‚æœä¸éœ€è¦ç›´æ¥è®¾ç½®0å³å¯
  
int dequeueInputBuffer(long timeoutUs)
// timeoutUsç­‰å¾…æ—¶é—´ï¼Œè¿”å›å¯ä»¥ä½¿ç”¨çš„è¾“å…¥bufferçš„ç´¢å¼•
  
// è®¾ç½®æŒ‡å®šç´¢å¼•ä½ç½®çš„bufferçš„ä¿¡æ¯
queueInputBuffer(
            int index,          // æ•°ç»„çš„ç´¢å¼•å€¼
            int offset,         // å†™å…¥bufferçš„èµ·å§‹ä½ç½®
            int size,           // å†™å…¥çš„è¾“å‡ºçš„é•¿åº¦
            long presentationTimeUs,    // è¯¥æ•°æ®æ˜¾ç¤ºçš„æ—¶é—´æˆ³
            int flags           // è¯¥æ•°æ®çš„æ ‡è®°ä½ï¼Œä¾‹å¦‚å…³é”®å¸§ï¼Œç»“æŸå¸§ç­‰ç­‰
)
  
int dequeueOutputBuffer(
            @NonNull BufferInfo info,  // è¿™ä¸ªBufferInfoéœ€è¦è‡ªå·±æ‰‹åŠ¨åˆ›å»ºï¼Œè°ƒç”¨åï¼Œä¼šæŠŠè¯¥ç´¢å¼•çš„æ•°æ®çš„ä¿¡æ¯å†™åœ¨é‡Œé¢
            long timeoutUs             // ç­‰å¾…æ—¶é—´
)
// timeoutUsç­‰å¾…æ—¶é—´ï¼Œè¿”å›å¯ä»¥è¯»å–çš„bufferçš„ç´¢å¼•
  
releaseOutputBuffer(int index, boolean render)ï¼šé‡Šæ”¾æŒ‡å®šç´¢å¼•ä½ç½®çš„buffer
// indexï¼šç´¢å¼•
// renderï¼šå¦‚æœç»‘å®šäº†surfaceï¼Œè¯¥æ•°æ®æ˜¯å¦è¦æ¸²æŸ“åˆ°ç”»å¸ƒä¸Š
```

MediaCodecæ˜¯ç³»ç»Ÿçº§åˆ«çš„ç¼–è§£ç åº“ï¼Œåº•å±‚è¿˜æ˜¯è°ƒç”¨nativeæ–¹æ³•ï¼Œä½¿ç”¨MediaCodecçš„åŸºæœ¬æµç¨‹æ˜¯ï¼š

**åˆ›å»ºä¸æ–‡ä»¶ç›¸åŒ¹é…çš„MediaCodec** -> **MediaCodecå†™å…¥æ•°æ®ï¼Œè¿›è¡Œç¼–ç /è§£ç ** -> **è¯»å–MediaCodecç¼–/è§£ç ç»“æœ**

ã€éŸ³é¢‘MediaCodecçš„å…·ä½“ä½¿ç”¨è¯¦è§éŸ³é¢‘ç¯‡ç¼–è§£ç ã€‘

***

### MediaExtractor

#### MediaExtractor ä»‹ç»

MediaExtractorå­—é¢æ„æ€æ˜¯å¤šåª’ä½“æå–å™¨ï¼Œå®ƒåœ¨Androidçš„éŸ³è§†é¢‘å¼€å‘é‡Œä¸»è¦è´Ÿè´£æå–è§†é¢‘æˆ–è€…éŸ³é¢‘ä¸­çš„ä¿¡æ¯å’Œæ•°æ®æµï¼ˆä¾‹å¦‚å°†è§†é¢‘æ–‡ä»¶ï¼Œè§£æå¤´ä¿¡æ¯ï¼Œå‰¥ç¦»å‡ºéŸ³é¢‘ä¸è§†é¢‘ï¼‰ã€‚

#### MediaExtractor API è¯´æ˜

- setDataSource(String path)ï¼šå³å¯ä»¥è®¾ç½®æœ¬åœ°æ–‡ä»¶åˆå¯ä»¥è®¾ç½®ç½‘ç»œæ–‡ä»¶
- getTrackCount()ï¼šå¾—åˆ°æºæ–‡ä»¶é€šé“æ•°
- getTrackFormat(int index)ï¼šè·å–æŒ‡å®šï¼ˆindexï¼‰çš„é€šé“æ ¼å¼
- getSampleTime()ï¼šè¿”å›å½“å‰çš„æ—¶é—´æˆ³
- readSampleData(ByteBuffer byteBuf, int offset)ï¼šæŠŠæŒ‡å®šé€šé“ä¸­çš„æ•°æ®æŒ‰åç§»é‡è¯»å–åˆ°ByteBufferä¸­ï¼›
- advance()ï¼šè¯»å–ä¸‹ä¸€å¸§æ•°æ®
- release(): è¯»å–ç»“æŸåé‡Šæ”¾èµ„æº

#### MediaExtractor ä½¿ç”¨

1. é€šè¿‡setDataSource()è®¾ç½®æ•°æ®æºï¼Œæ•°æ®æºå¯ä»¥æ˜¯æœ¬åœ°æ–‡ä»¶åœ°å€ï¼Œä¹Ÿå¯ä»¥æ˜¯ç½‘ç»œåœ°å€

    ``` java
    MediaExtractor mVideoExtractor = new MediaExtractor();
    mVideoExtractor.setDataSource(mVideoPath);
    ```

2. å¯ä»¥é€šè¿‡getTrackFormat(int index)æ¥è·å–å„ä¸ªtrackçš„MediaFormatï¼Œé€šè¿‡MediaFormatæ¥è·å–trackçš„è¯¦ç»†ä¿¡æ¯ï¼Œå¦‚ï¼šMimeTypeã€åˆ†è¾¨ç‡ã€é‡‡æ ·é¢‘ç‡ã€å¸§ç‡ç­‰ç­‰

    ``` java
    for (int i = 0; i < mVideoExtractor.getTrackCount(); i++) {
        MediaFormat format = mVideoExtractor.getTrackFormat(i);
    }
    
    // MediaFormat: å°è£…æè¿°åª’ä½“æ•°æ®æ ¼å¼çš„ä¿¡æ¯ï¼Œæ— è®ºæ˜¯éŸ³é¢‘è¿˜æ˜¯è§†é¢‘ã€‚åª’ä½“æ•°æ®çš„æ ¼å¼è¢«æŒ‡å®šä¸ºå­—ç¬¦ä¸²/å€¼å¯¹ã€‚
    
    // ã€è‚¯å®šå¯ä»¥è·å–åˆ°çš„ã€‘
    // è·å–MIMEä¿¡æ¯
    MediaFormat mediaFormat = extractor.getTrackFormat(0);//è·å–å¤šåª’ä½“æ ¼å¼,å› ä¸ºæ˜¯demoå·²ç»ç¡®å®šè‡ªå·±çš„è§†é¢‘æ–‡ä»¶æ²¡é—®é¢˜,æ‰€ä»¥ç›´æ¥è·å–0ä½è½¨é“
    String mimeFormat = mediaFormat.getString(MediaFormat.KEY_MIME);//è·å–MIMEæ ¼å¼å†…å®¹
    Log.e(TAG, "mediaExtractor: è·å–MIMEæ ¼å¼å†…å®¹="+mimeFormat);
    // è·å–è¯­è¨€æ ¼å¼(å¤§å¤šæ•°æƒ…å†µæ˜¯è·å–åˆ°ç©ºçš„å­—ç¬¦ä¸²,ä½†æ˜¯è‡³å°‘ä¸ä¼šæŠ¥null)
    MediaFormat mediaFormat = extractor.getTrackFormat(0);
    String language = mediaFormat.getString(MediaFormat.KEY_LANGUAGE);//è·å–è¯­è¨€æ ¼å¼å†…å®¹
    Log.e(TAG, "mediaExtractor: è·å–è¯­è¨€æ ¼å¼å†…å®¹="+language);
    // è§†é¢‘çš„é«˜åº¦ä¸å®½åº¦
    MediaFormat mediaFormat = extractor.getTrackFormat(0);
    int width = mediaFormat.getInteger(MediaFormat.KEY_WIDTH);//è·å–é«˜åº¦
    int height = mediaFormat.getInteger(MediaFormat.KEY_HEIGHT);//è·å–é«˜åº¦
    // æ’­æ”¾æ€»æ—¶é•¿
    long durationTime = mediaFormat.getLong(MediaFormat.KEY_DURATION);//æ€»æ—¶é—´
    // è·å–MediaFormatæè¿°çš„æ•°æ®ç¼“å†²åŒºçš„æœ€å¤§å­—èŠ‚æ•°
    int maxByteCount = mediaFormat.getInteger(MediaFormat.KEY_MAX_INPUT_SIZE);//è·å–è§†é¢‘ç¼“å­˜è¾“å‡ºçš„æœ€å¤§å¤§å°
    
    // ã€ä¸ä¸€å®šèƒ½è·å–åˆ°ï¼Œæ²¡æœ‰åˆ™ä¼šç©ºæŒ‡é’ˆã€‘
    // è·å–é‡‡æ ·ç‡
    int sampleRate = mediaFormat.getInteger(MediaFormat.KEY_SAMPLE_RATE);//è·å–é‡‡æ ·ç‡
    // è·å–æ¯”ç‰¹ç‡
    int bitRate = mediaFormat.getInteger(MediaFormat.KEY_BIT_RATE);//è·å–æ¯”ç‰¹
    // è·å–å£°é“æ•°é‡
    int channelCount = mediaFormat.getInteger(MediaFormat.KEY_CHANNEL_COUNT);//è·å–å£°é“æ•°é‡
    // è·å–æœ€å¤§é«˜åº¦ä¸æœ€å¤§å®½åº¦
    int maxWidth = mediaFormat.getInteger(MediaFormat.KEY_MAX_WIDTH);//æœ€å¤§å®½åº¦
    int maxHeight = mediaFormat.getInteger(MediaFormat.KEY_MAX_HEIGHT);//æœ€å¤§é«˜åº¦
    // è·å–é¢œè‰²æ ¼å¼
    int colorFormat = mediaFormat.getInteger(MediaFormat.KEY_COLOR_FORMAT);//é¢œè‰²æ ¼å¼
    // è·å–å¸§ç‡
    int frameRate = mediaFormat.getInteger(MediaFormat.KEY_FRAME_RATE);//å¸§ç‡
    ```

3. è·å–åˆ°trackçš„è¯¦ç»†ä¿¡æ¯åï¼Œé€šè¿‡selectTrack(int index)é€‰æ‹©æŒ‡å®šçš„é€šé“

    ``` java
    if (format.getString(MediaFormat.KEY_MIME).startsWith("video/")) {
        mVideoExtractor.selectTrack(i);
        break;
    }
    ```

4. æŒ‡å®šé€šé“ä¹‹åå°±å¯ä»¥ä»MediaExtractorä¸­è¯»å–æ•°æ®äº†

    ``` java
    while (true) {
        int sampleSize = mVideoExtractor.readSampleData(buffer, 0);
        if (sampleSize < 0) {
        break;
        }
        // do something
        mVideoExtractor.advance(); // ç§»åŠ¨åˆ°ä¸‹ä¸€å¸§
    }
    ```

5. åœ¨è¯»å–ç»“æŸä¹‹åï¼Œè®°å¾—é‡Šæ”¾èµ„æº

    ``` java
    mVideoExtractor.release();
    ```

***

### MediaMuxer

#### MediaMuxer ä»‹ç»

åˆ©ç”¨MediaExtractoræå–çš„aacå’Œ.h264æ–‡ä»¶ä¸ç»è¿‡å¤„ç†æ²¡åŠæ³•æ’­æ”¾ï¼Œéœ€è¦MediaMuxeråˆå¹¶ç”Ÿæˆå¯ä»¥æ’­æ”¾çš„æ–‡ä»¶ï¼ˆaacæ–‡ä»¶å’Œ.h264éœ€è¦é¦–å…ˆåˆ©ç”¨MediaMuxerç”ŸæˆMP4æ–‡ä»¶ï¼Œæ‰èƒ½è¿›è¡Œåˆå¹¶ï¼‰ã€‚

MediaMuxerä»api18å¼€å§‹æä¾›ï¼Œå¯ä»¥å°è£…ç¼–ç åçš„è§†é¢‘æµå’ŒéŸ³é¢‘æµåˆ°è§†é¢‘æ–‡ä»¶ä¸­ã€‚ç›®å‰MediaMuxeræ”¯æŒçš„æ–‡ä»¶è¾“å‡ºæ ¼å¼åŒ…æ‹¬MP4ï¼Œwebmå’Œ3gpã€‚

{% asset_img 4.webp %}

#### MediaMuxer API è¯´æ˜

- MediaMuxer(String path, int format)
- addTrack(MediaFormat format)ï¼šåˆ©ç”¨MediaFormatæ·»åŠ éŸ³é¢‘æˆ–è§†é¢‘è½¨é“
- release()ï¼šé‡Šæ”¾MediaMuxerçš„èµ„æº
- setLocation(float latitude,float longitude)ï¼šè®¾ç½®å¹¶å­˜å‚¨åœ°ç†ä½ç½®ä¿¡æ¯åˆ°ç”Ÿæˆæ–‡ä»¶ä¸­
- setOrientationHint(int degrees)ï¼šè®¾ç½®è¾“å‡ºè§†é¢‘å›æ”¾çš„æ–¹å‘æç¤º
- start()ï¼šå¼€å§‹muxerï¼Œç­‰å¾…æ•°æ®çš„è¾“å…¥
- stop()ï¼šåœæ­¢muxerï¼Œè°ƒç”¨è¿™ä¸ªå‡½æ•°åå°†ç”Ÿæˆåˆæˆçš„æ–‡ä»¶
- writeSampleData(int trackIndex, ByteBuffer byteBuf, MediaCodec.BufferInfo bufferInfo)ï¼šå¾€muxerä¸­å†™å…¥ç¼–ç çš„æ•°æ®ã€‚

#### MediaMuxer ä½¿ç”¨

1. ç”ŸæˆMediaMuxerå¯¹è±¡ï¼š

    é€šè¿‡new MediaMuxer(String path, int format)æŒ‡å®šè§†é¢‘æ–‡ä»¶è¾“å‡ºè·¯å¾„å’Œæ–‡ä»¶æ ¼å¼ï¼š
    MediaMuxer mMediaMuxer = new MediaMuxer(mOutputVideoPath, MediaMuxer.OutputFormat.MUXER_OUTPUT_MPEG_4);

2. addTrack

    addTrack(MediaFormat format)ï¼Œæ·»åŠ åª’ä½“é€šé“ï¼Œä¼ å…¥MediaFormatå¯¹è±¡ï¼Œé€šå¸¸ä»MediaExtractoræˆ–è€…MediaCodecä¸­è·å–ï¼Œä¹Ÿå¯ä»¥è‡ªå·±åˆ›å»º
    addTrackä¼šè¿”å›trackindex

3. è°ƒç”¨startå‡½æ•°

    MediaMuxer.start();

4. å†™å…¥æ•°æ®

    è°ƒç”¨MediaMuxer.writeSampleData()å‘mp4æ–‡ä»¶ä¸­å†™å…¥æ•°æ®äº†ã€‚æ¯æ¬¡åªèƒ½æ·»åŠ ä¸€å¸§è§†é¢‘æ•°æ®æˆ–è€…å•ä¸ªSampleçš„éŸ³é¢‘æ•°æ®ï¼Œéœ€è¦BufferInfoå¯¹è±¡ä½œä¸ºå‚æ•°ã€‚
    BufferInfo info = new BufferInfo();
    info.offset = 0;
    info.size = sampleSize;
    info.flags = MediaCodec.BUFFER_FLAG_SYNC_FRAME;
    info.presentationTimeUs = mVideoExtractor.getSampleTime();
    mMediaMuxer.writeSampleData(videoTrackIndex, buffer, info);
    info.size å¿…é¡»å¡«å…¥æ•°æ®çš„å¤§å°
    info.flags éœ€è¦ç»™å‡ºæ˜¯å¦ä¸ºåŒæ­¥å¸§/å…³é”®å¸§
    info.presentationTimeUs å¿…é¡»ç»™å‡ºæ­£ç¡®çš„æ—¶é—´æˆ³ï¼Œæ³¨æ„å•ä½æ˜¯ usï¼Œç¬¬äºŒæ¬¡getSampleTime()å’Œé¦–æ¬¡getSampleTime()çš„æ—¶é—´å·®ã€‚

5. é‡Šæ”¾å…³é—­èµ„æº

    ç»“æŸå†™å…¥åå…³é—­ä»¥åŠé‡Šæ”¾èµ„æºï¼š
    MediaMuxer.stop();
    MediaMuxer.release();

å®˜ç½‘say that it is generally used like this:

``` java
MediaMuxer muxer = new MediaMuxer("temp.mp4", OutputFormat.MUXER_OUTPUT_MPEG_4);
// More often, the MediaFormat will be retrieved from MediaCodec.getOutputFormat()
// or MediaExtractor.getTrackFormat().
MediaFormat audioFormat = new MediaFormat(...);
MediaFormat videoFormat = new MediaFormat(...);
int audioTrackIndex = muxer.addTrack(audioFormat);
int videoTrackIndex = muxer.addTrack(videoFormat);
ByteBuffer inputBuffer = ByteBuffer.allocate(bufferSize);
boolean finished = false;
BufferInfo bufferInfo = new BufferInfo();
 
muxer.start();
while(!finished) {
  // getInputBuffer() will fill the inputBuffer with one frame of encoded
  // sample from either MediaCodec or MediaExtractor, set isAudioSample to
  // true when the sample is audio data, set up all the fields of bufferInfo,
  // and return true if there are no more samples.
  finished = getInputBuffer(inputBuffer, isAudioSample, bufferInfo);
  if (!finished) {
    int currentTrackIndex = isAudioSample ? audioTrackIndex : videoTrackIndex;
    muxer.writeSampleData(currentTrackIndex, inputBuffer, bufferInfo);
  }
};
muxer.stop();
muxer.release();
```

***

### ç»¼åˆä¾‹å­

#### è§†é¢‘æ¢éŸ³

ä½¿ç”¨MediaExtractorå’ŒMediaMuxeræ¥å®ç°è§†é¢‘çš„æ¢éŸ³

``` java
private void muxingAudioAndVideo() throws IOException {
    MediaMuxer mMediaMuxer = new MediaMuxer(mOutputVideoPath,
                MediaMuxer.OutputFormat.MUXER_OUTPUT_MPEG_4);
 
    // è§†é¢‘çš„MediaExtractor
    MediaExtractor mVideoExtractor = new MediaExtractor();
    mVideoExtractor.setDataSource(mVideoPath);
    int videoTrackIndex = -1;
    for (int i = 0; i < mVideoExtractor.getTrackCount(); i++) {
        MediaFormat format = mVideoExtractor.getTrackFormat(i);
        if (format.getString(MediaFormat.KEY_MIME).startsWith("video/")) {
            mVideoExtractor.selectTrack(i);
            videoTrackIndex = mMediaMuxer.addTrack(format);
            break;
        }
    }
 
    // éŸ³é¢‘çš„MediaExtractor
    MediaExtractor mAudioExtractor = new MediaExtractor();
    mAudioExtractor.setDataSource(mAudioPath);
    int audioTrackIndex = -1;
    for (int i = 0; i < mAudioExtractor.getTrackCount(); i++) {
        MediaFormat format = mAudioExtractor.getTrackFormat(i);
        if (format.getString(MediaFormat.KEY_MIME).startsWith("audio/")) {
            mAudioExtractor.selectTrack(i);
            audioTrackIndex = mMediaMuxer.addTrack(format);
        }
    }
 
    // æ·»åŠ å®Œæ‰€æœ‰è½¨é“åstart
    mMediaMuxer.start();
 
    // å°è£…è§†é¢‘track
    if (-1 != videoTrackIndex) {
        MediaCodec.BufferInfo info = new MediaCodec.BufferInfo();
        info.presentationTimeUs = 0;
        ByteBuffer buffer = ByteBuffer.allocate(100 * 1024);
        while (true) {
            int sampleSize = mVideoExtractor.readSampleData(buffer, 0);
            if (sampleSize < 0) {
                break;
            }
 
            info.offset = 0;
            info.size = sampleSize;
            info.flags = MediaCodec.BUFFER_FLAG_SYNC_FRAME;
            info.presentationTimeUs = mVideoExtractor.getSampleTime();
            mMediaMuxer.writeSampleData(videoTrackIndex, buffer, info);
 
            mVideoExtractor.advance();
        }
    }
 
    // å°è£…éŸ³é¢‘track
    if (-1 != audioTrackIndex) {
        MediaCodec.BufferInfo info = new MediaCodec.BufferInfo();
        info.presentationTimeUs = 0;
        ByteBuffer buffer = ByteBuffer.allocate(100 * 1024);
        while (true) {
            int sampleSize = mAudioExtractor.readSampleData(buffer, 0);
            if (sampleSize < 0) {
                break;
            }
 
            info.offset = 0;
            info.size = sampleSize;
            info.flags = MediaCodec.BUFFER_FLAG_SYNC_FRAME;
            info.presentationTimeUs = mAudioExtractor.getSampleTime();
            mMediaMuxer.writeSampleData(audioTrackIndex, buffer, info);
 
            mAudioExtractor.advance();
        }
    }
 
    // é‡Šæ”¾MediaExtractor
    mVideoExtractor.release();
    mAudioExtractor.release();
 
    // é‡Šæ”¾MediaMuxer
    mMediaMuxer.stop();
    mMediaMuxer.release();
}
```

#### ç¡¬è§£ç h.265è§†é¢‘åŠéŸ³é¢‘è¿›è¡Œæ’­æ”¾

è§†é¢‘è§£ç 

``` java
// ã€è®¾ç½®æ•°æ®æºã€‘
MediaExtractor mediaExtractor = new MediaExtractor();
try {
    mediaExtractor.setDataSource(path); // è®¾ç½®æ•°æ®æº
} catch (IOException e1) {
    e1.printStackTrace();
}
 
// ã€æ ¹æ®è§†é¢‘çš„ç¼–ç ä¿¡æ¯æ¥åˆå§‹åŒ–MediaCodec: è§†é¢‘çš„mimeTypeæ˜¯videoç±»å‹ã€‚ã€‘
String mimeType = null;
for (int i = 0; i < mediaExtractor.getTrackCount(); i++) { // ä¿¡é“æ€»æ•°
    MediaFormat format = mediaExtractor.getTrackFormat(i); // éŸ³é¢‘æ–‡ä»¶ä¿¡æ¯
    mimeType = format.getString(MediaFormat.KEY_MIME);
    if (mimeType.startsWith("video/")) { // è§†é¢‘ä¿¡é“
        mediaExtractor.selectTrack(i); // åˆ‡æ¢åˆ°è§†é¢‘ä¿¡é“
        try {
            mediaCodec = MediaCodec.createDecoderByType(mimeType); // åˆ›å»ºè§£ç å™¨,æä¾›æ•°æ®è¾“å‡º
        } catch (IOException e) {
            e.printStackTrace();
        }
        mediaCodec.configure(format, surface, null, 0);
        break;
    }
}
mediaCodec.start(); // å¯åŠ¨MediaCodec ï¼Œç­‰å¾…ä¼ å…¥æ•°æ®
 
// ã€è·å–ç¼“å­˜å™¨ã€‘
// è¾“å…¥
ByteBuffer[] inputBuffers = mediaCodec.getInputBuffers(); // ç”¨æ¥å­˜æ”¾ç›®æ ‡æ–‡ä»¶çš„æ•°æ®
// è¾“å‡º
ByteBuffer[] outputBuffers = mediaCodec.getOutputBuffers(); // è§£ç åçš„æ•°æ®
MediaCodec.BufferInfo info = new MediaCodec.BufferInfo(); // ç”¨äºæè¿°è§£ç å¾—åˆ°çš„byte[]æ•°æ®çš„ç›¸å…³ä¿¡æ¯
 
// ã€å¼€å§‹è§£ç ã€‘
while (!Thread.interrupted()) {
    if (!bIsEos) {
        int inIndex = mediaCodec.dequeueInputBuffer(0);
        if (inIndex >= 0) {
            ByteBuffer buffer = inputBuffers[inIndex];
            int nSampleSize = mediaExtractor.readSampleData(buffer, 0); // è¯»å–ä¸€å¸§æ•°æ®è‡³bufferä¸­
            if (nSampleSize < 0) {
                Log.d(TAG, "InputBuffer BUFFER_FLAG_END_OF_STREAM");
                mediaCodec.queueInputBuffer(inIndex, 0, 0, 0, MediaCodec.BUFFER_FLAG_END_OF_STREAM);
                bIsEos = true;
            } else {
                // å¡«æ•°æ®
                mediaCodec.queueInputBuffer(inIndex, 0, nSampleSize, mediaExtractor.getSampleTime(), 0); // é€šçŸ¥MediaDecodeè§£ç åˆšåˆšä¼ å…¥çš„æ•°æ®
                mediaExtractor.advance(); // ç»§ç»­ä¸‹ä¸€å–æ ·
            }
        }
    }
    int outIndex = mediaCodec.dequeueOutputBuffer(info, 0);
    switch (outIndex) {
        case MediaCodec.INFO_OUTPUT_BUFFERS_CHANGED:
            Log.d(TAG, "INFO_OUTPUT_BUFFERS_CHANGED");
            outputBuffers = mediaCodec.getOutputBuffers();
            break;
        case MediaCodec.INFO_OUTPUT_FORMAT_CHANGED:
            Log.d(TAG, "New format " + mediaCodec.getOutputFormat());
            break;
        case MediaCodec.INFO_TRY_AGAIN_LATER:
            Log.d(TAG, "dequeueOutputBuffer timed out!");
            break;
        default:
            ByteBuffer buffer = outputBuffers[outIndex];
            Log.v(TAG, "We can't use this buffer but render it due to the API limit, " + buffer);
 
            mediaCodec.releaseOutputBuffer(outIndex, true);
            break;
    }
    if ((info.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0) {
        Log.d("DecodeActivity", "OutputBuffer BUFFER_FLAG_END_OF_STREAM");
        break;
    }
}
 
// ã€è§£ç å®Œæˆåé‡Šæ”¾èµ„æºã€‘
mediaCodec.stop();
mediaCodec.release();
mediaExtractor.release();
```

è¿™æ ·è§†é¢‘çš„è§£ç å°±å·²ç»å®Œæˆäº†ï¼Œæ­¤æ—¶surfaceViewå·²ç»å¯ä»¥æ’­æ”¾è§†é¢‘äº†ï¼Œæ¥ä¸‹æ¥æ˜¯éŸ³é¢‘è§£ç ã€‚

éŸ³é¢‘è§£ç çš„è¿‡ç¨‹å’Œä¸Šé¢å¤§åŒå°å¼‚ï¼Œä¸»è¦åŒºåˆ«åœ¨äºï¼Œè§†é¢‘æ˜¯ç”¨surfaceViewæ’­æ”¾æ˜¾ç¤ºçš„ï¼Œè€ŒéŸ³é¢‘æˆ‘ä»¬éœ€è¦ä½¿ç”¨AudioTrackæ¥æ’­æ”¾ã€‚

éŸ³é¢‘è§£ç 

``` java
// ã€åˆ›å»ºä¸€ä¸ªAudioPlayerç±»ç”¨äºæ’­æ”¾éŸ³é¢‘ã€‘
public class AudioPlayer {
    private int mFrequency;// é‡‡æ ·ç‡
    private int mChannel;// å£°é“
    private int mSampBit;// é‡‡æ ·ç²¾åº¦
    private AudioTrack mAudioTrack;
 
    public AudioPlayer(int frequency, int channel, int sampbit) {
        this.mFrequency = frequency;
        this.mChannel = channel;
        this.mSampBit = sampbit;
    }
 
    /**
     * åˆå§‹åŒ–
     */
    public void init() {
        if (mAudioTrack != null) {
            release();
        }
        // è·å¾—æ„å»ºå¯¹è±¡çš„æœ€å°ç¼“å†²åŒºå¤§å°
        int minBufSize = AudioTrack.getMinBufferSize(mFrequency, mChannel, mSampBit);
        mAudioTrack = new AudioTrack(AudioManager.STREAM_MUSIC,
                mFrequency, mChannel, mSampBit, minBufSize, AudioTrack.MODE_STREAM);
        mAudioTrack.play();
    }
 
    /**
     * é‡Šæ”¾èµ„æº
     */
    private void release() {
        if (mAudioTrack != null) {
            mAudioTrack.stop();
            mAudioTrack.release();
        }
    }
 
    /**
     * å°†è§£ç åçš„pcmæ•°æ®å†™å…¥audioTrackæ’­æ”¾
     *
     * @param data   æ•°æ®
     * @param offset åç§»
     * @param length éœ€è¦æ’­æ”¾çš„é•¿åº¦
     */
    public void play(byte[] data, int offset, int length) {
        if (data == null || data.length == 0) {
            return;
        }
        try {
            mAudioTrack.write(data, offset, length);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
 
// ã€åˆå§‹åŒ–éŸ³é¢‘è§£ç å™¨ï¼šéŸ³é¢‘çš„mineTypeæ˜¯audioç±»å‹ï¼Œæˆ‘ä»¬æ ¹æ®è¿™ä¸ªæ¥å»éŸ³é¢‘ä¿¡æ¯å³å¯ã€‚ã€‘
String mimeType;
for (int i = 0; i < mediaExtractor.getTrackCount(); i++) { // ä¿¡é“æ€»æ•°
    MediaFormat format = mediaExtractor.getTrackFormat(i); // éŸ³é¢‘æ–‡ä»¶ä¿¡æ¯
    mimeType = format.getString(MediaFormat.KEY_MIME);
    if (mimeType.startsWith("audio/")) { // éŸ³é¢‘ä¿¡é“
        mediaExtractor.selectTrack(i); // åˆ‡æ¢åˆ° éŸ³é¢‘ä¿¡é“
        try {
            mediaCodec = MediaCodec.createDecoderByType(mimeType); // åˆ›å»ºè§£ç å™¨,æä¾›æ•°æ®è¾“å‡º
        } catch (IOException e) {
            e.printStackTrace();
        }
        mediaCodec.configure(format, null, null, 0);
        mPlayer = new AudioPlayer(format.getInteger(MediaFormat.KEY_SAMPLE_RATE), AudioFormat
                .CHANNEL_OUT_STEREO, AudioFormat.ENCODING_PCM_16BIT);
        mPlayer.init();
        break;
    }
}
if (mediaCodec == null) {
    Log.e(TAG, "Can't find video info!");
    return;
}
 
mediaCodec.start(); // å¯åŠ¨MediaCodec ï¼Œç­‰å¾…ä¼ å…¥æ•°æ®
 
// ã€éŸ³é¢‘è§£ç ï¼šéŸ³é¢‘è§£ç è¿‡ç¨‹ä¸è§†é¢‘è§£ç å¤§åŒå°å¼‚ï¼Œåªéœ€è¦é¢å¤–è°ƒç”¨ä¸€ä¸‹æˆ‘ä»¬åˆ›å»ºçš„AudioPlayeræ¥æ’­æ”¾éŸ³é¢‘å³å¯ã€‚ã€‘
while (!Thread.interrupted()) {
 
    if (!bIsEos) {
        int inIndex = mediaCodec.dequeueInputBuffer(0);
        if (inIndex >= 0) {
            ByteBuffer buffer = inputBuffers[inIndex];
            int nSampleSize = mediaExtractor.readSampleData(buffer, 0); // è¯»å–ä¸€å¸§æ•°æ®è‡³bufferä¸­
            if (nSampleSize < 0) {
                Log.d(TAG, "InputBuffer BUFFER_FLAG_END_OF_STREAM");
                mediaCodec.queueInputBuffer(inIndex, 0, 0, 0, MediaCodec.BUFFER_FLAG_END_OF_STREAM);
                bIsEos = true;
            } else {
                // å¡«æ•°æ®
                mediaCodec.queueInputBuffer(inIndex, 0, nSampleSize, mediaExtractor.getSampleTime(), 0); // é€šçŸ¥MediaDecodeè§£ç åˆšåˆšä¼ å…¥çš„æ•°æ®
                mediaExtractor.advance(); // ç»§ç»­ä¸‹ä¸€å–æ ·
            }
        }
    }
 
    int outIndex = mediaCodec.dequeueOutputBuffer(info, 0);
    switch (outIndex) {
        case MediaCodec.INFO_OUTPUT_BUFFERS_CHANGED:
            Log.d(TAG, "INFO_OUTPUT_BUFFERS_CHANGED");
            outputBuffers = mediaCodec.getOutputBuffers();
            break;
        case MediaCodec.INFO_OUTPUT_FORMAT_CHANGED:
            Log.d(TAG, "New format " + mediaCodec.getOutputFormat());
            break;
        case MediaCodec.INFO_TRY_AGAIN_LATER:
            Log.d(TAG, "dequeueOutputBuffer timed out!");
            break;
        default:
            ByteBuffer buffer = outputBuffers[outIndex];
            Log.v(TAG, "We can't use this buffer but render it due to the API limit, " + buffer);
 
            while (info.presentationTimeUs / 1000 > System.currentTimeMillis() - startMs) {
                try {
                    sleep(10);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                    break;
                }
            }
            //ç”¨æ¥ä¿å­˜è§£ç åçš„æ•°æ®
            byte[] outData = new byte[info.size];
            buffer.get(outData);
            //æ¸…ç©ºç¼“å­˜
            buffer.clear();
            //æ’­æ”¾è§£ç åçš„æ•°æ®
            mPlayer.play(outData, 0, info.size);
            mediaCodec.releaseOutputBuffer(outIndex, true);
            break;
    }
 
    // All decoded frames have been rendered, we can stop playing
    // now
    if ((info.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0) {
        Log.d("DecodeActivity", "OutputBuffer BUFFER_FLAG_END_OF_STREAM");
        break;
    }
}
```

***

### å‚è€ƒä¸é¸£è°¢

> <https://www.cnblogs.com/renhui/p/7478527.html>
> <https://www.jianshu.com/p/e7eae2541e01>
> <https://www.cnblogs.com/guanxinjing/p/11378133.html>
> <https://www.jianshu.com/p/66acab100e4b>
> <https://blog.csdn.net/qq_25412055/article/details/78990538>
> <https://blog.csdn.net/u010126792/article/details/86510903>
