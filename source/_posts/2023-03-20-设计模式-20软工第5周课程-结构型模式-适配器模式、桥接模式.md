---
title: 设计模式-20软工第5周课程-结构型模式-适配器模式、桥接模式
categories:
  - 🌙基础学习
  - ⭐设计模式
abbrlink: 6c8388a8
date: 2023-03-20 20:44:18
tags:
---

**也可以看我大三以前的上这门课时的博客：**
> [设计模式-GoF的23种设计模式](https://aisakaaoi.top/ad03970c.html)
> [设计模式-如何正确使用设计模式](https://aisakaaoi.top/f9eefb8d.html)
> [设计模式-一句话归纳设计模式](https://aisakaaoi.top/d3e0084b.html)
> [设计模式-结构型模式-结构型模式概述](https://aisakaaoi.top/a6277c23.html)
> [设计模式-结构型模式-适配器模式](https://aisakaaoi.top/557ee5c2.html)
> [设计模式-结构型模式-桥接模式](https://aisakaaoi.top/ec45913f.html)

<!--more-->

***

先简单介绍一下我自己

| {% asset_img 1.jpg %} | {% asset_img 2.jpg %} | {% asset_img 3.jpg %} |
| --- | ---| --- |

https://aisakaaoi.top/

***

### 设计模式分类方法

即根据模式的目的来分和根据模式的作用的范围来分。

#### 根据目的来分
根据模式是用来完成什么工作来划分，这种方式可分为创建型模式、结构型模式和行为型模式 3 种。
- **创建型模式：**用于描述“怎样创建对象”，它的主要特点是“将对象的创建与使用分离”。GoF 中提供了**单例、原型、工厂方法、抽象工厂、建造者**等 5 种创建型模式。
- **结构型模式：**用于描述如何将类或对象按某种布局组成更大的结构，GoF 中提供了代理、**适配器**、**桥接**、装饰、外观、享元、组合等 7 种结构型模式。
- 行为型模式：用于描述类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务，以及怎样分配职责。GoF 中提供了模板方法、策略、命令、职责链、状态、观察者、中介者、迭代器、访问者、备忘录、解释器等 11 种行为型模式。

#### 根据**作用范围**来分
根据模式是主要用于类上还是主要用于对象上来分，这种方式可分为类模式和对象模式两种。
- 类模式：用于处理类与子类之间的关系，这些关系通过继承来建立，是静态的，在编译时刻便确定下来了。GoF中的工厂方法、（类）适配器、模板方法、解释器属于该模式。
- 对象模式：用于处理对象之间的关系，这些关系可以通过组合或聚合来实现，在运行时刻是可以变化的，更具动态性。GoF 中除了以上 4 种，其他的都是对象模式。

***

### 设计模式的功能

- 单例（Singleton）模式：某个类只能生成一个实例，该类提供了一个全局访问点供外部获取该实例，其拓展是有限多例模式。
- 原型（Prototype）模式：将一个对象作为原型，通过对其进行复制而克隆出多个和原型类似的新实例。
- 工厂方法（Factory Method）模式：定义一个用于创建产品的接口，由子类决定生产什么产品。
- 抽象工厂（AbstractFactory）模式：提供一个创建产品族的接口，其每个子类可以生产一系列相关的产品。
- 建造者（Builder）模式：将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建成该复杂对象。
- **适配器（Adapter）模式：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。**
- **桥接（Bridge）模式：将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。**

{% asset_img 4.jpg %}

| 分类 | 设计模式 | 简述 | 一句话归纳 | 目的 | 生活案例 |
| ---- | ------- | ---- | -------- | ---- | -------- |
| 创建型设计模式<br>（用来创建对象的） | 工厂模式<br>Factory Pattern | 不同条件下创建不同实例 | 产品标准化<br>生产更高效 | 封装创建细节	| 实体工厂 |
|  | 单例模式<br>Singleton Pattern | 保证一个类仅有一个实例<br>并且提供一个全局访问点 | 世上只有一个我 | 保证独一无二 | CEO |
|  | 原型模式<br>Prototype Pattern | 通过拷贝原型创建新的对象 | 拔一根猴毛<br>吹出千万个 | 高效创建对象	| 克隆 |
|  | 建造者模式<br>Builder Pattern | 用来创建复杂的复合对象 | 高配中配和低配<br>想选哪配就哪配 | 开放个性配置步骤 | 选配 |
| 结构型设计模式<br>（关注类和对象的组合） | 适配器模式<br>Adapter Pattern | 将原来不兼容的两个类融合在一起 | 万能充电器 | 兼容转换 | 电源适配 |
|  | 桥接模式<br>Bridge Pattern | 将两个能够独立变化的部分分离开 | 约定优于配置 | 不允许用继承 | 桥 |

***

### 适配器模式

{% asset_img 第10章适配器模式幻灯片1.png %}

{% asset_img 第10章适配器模式幻灯片2.png %}

{% asset_img 第10章适配器模式幻灯片3.png %}

{% asset_img 第10章适配器模式幻灯片4.png %}

每种模式都有其实现思想，实现方式往往也不会特别复杂，重要的是对不同数据之间的结构的组合变化，例如多用接口、少用继承，多用现成、少写重复

{% asset_img 第10章适配器模式幻灯片5.png %}

{% asset_img 第10章适配器模式幻灯片6.png %}

最方便的，那肯定是直接复制代码过来，但现在的问题是，**不知道源码**
从一个小算法来看，复制过来很简单，但如果这个算法是很复杂的中间件呢，比如调用后端的一些响应
那总不可能直接把中台的中间件代码包整个复制进来吧，只会越来越臃肿
同时也要符合“开闭原则”，不要修改以前的代码

{% asset_img 第10章适配器模式幻灯片7.png %}

{% asset_img 第10章适配器模式幻灯片8.png %}

{% asset_img 第10章适配器模式幻灯片9.png %}

{% asset_img 第10章适配器模式幻灯片10.png %}

{% asset_img 第10章适配器模式幻灯片11.png %}

用Client的request()方法去调用第三方的specificRequest()

{% asset_img 第10章适配器模式幻灯片12.png %}

{% asset_img 第10章适配器模式幻灯片13.png %}

{% asset_img 第10章适配器模式幻灯片14.png %}

关于这个Adaptee怎么创建，就可以结合之前的单例、工厂等创建型模式

{% asset_img 第10章适配器模式幻灯片15.png %}

{% asset_img 第10章适配器模式幻灯片16.png %}

用cry()触发wang()，以wang()代cry()；用move()触发run()，以run()代move()

{% asset_img 第10章适配器模式幻灯片17.png %}

- **p156 3(1)** 定义一个Robot接口，有cry()和move()方法需要实现
- **p156 3(2)** 已有的Dog类，里面有wang()和run()方法
- **p156 3(3)** 适配器DogAdapter类 **继承** Dog类，所以拥有wang()和run()方法
    - 适配器DogAdapter类有Robot接口，所以需要实现cry()和move()
    - 所以在cry()中调用wang()，move()中调用run()就能实现效果
- **p157 4(3)** 因为DogAdapter实现了Robot接口，所以它可以用Robot引用来指名
    - 在外部隐藏了Adapter的细节，直接cry()就完事了

{% asset_img 第10章适配器模式幻灯片18.png %}

{% asset_img 第10章适配器模式幻灯片19.png %}

{% asset_img 第10章适配器模式幻灯片20.png %}

{% asset_img 第10章适配器模式幻灯片21.png %}

{% asset_img 第10章适配器模式幻灯片22.png %}

{% asset_img 第10章适配器模式幻灯片23.png %}

{% asset_img 第10章适配器模式幻灯片24.png %}

***

### 桥接模式

{% asset_img 第11章桥接模式幻灯片1.png %}

{% asset_img 第11章桥接模式幻灯片2.png %}

{% asset_img 第11章桥接模式幻灯片3.png %}

{% asset_img 第11章桥接模式幻灯片4.png %}

{% asset_img 第11章桥接模式幻灯片5.png %}

{% asset_img 第11章桥接模式幻灯片6.png %}

{% asset_img 第11章桥接模式幻灯片7.png %}

{% asset_img 第11章桥接模式幻灯片8.png %}

{% asset_img 第11章桥接模式幻灯片9.png %}

{% asset_img 第11章桥接模式幻灯片10.png %}

{% asset_img 第11章桥接模式幻灯片11.png %}

{% asset_img 第11章桥接模式幻灯片12.png %}

{% asset_img 第11章桥接模式幻灯片13.png %}

{% asset_img 第11章桥接模式幻灯片14.png %}

{% asset_img 第11章桥接模式幻灯片15.png %}

{% asset_img 第11章桥接模式幻灯片16.png %}

{% asset_img 第11章桥接模式幻灯片17.png %}

{% asset_img 第11章桥接模式幻灯片18.png %}

{% asset_img 第11章桥接模式幻灯片19.png %}

- p173 3(1) Color接口，等待实现具体颜色
- p174 3(2) Red具体颜色类，实现了Color接口
- p174 3(3) Green具体颜色类，同理
...
- p175 3(7) Pen抽象毛笔类，等着给颜色和笔的大小
- p175 3(8) BigPen继承抽象Pen，赋予了笔的大小
    - 具体颜色则等着生成具体颜色类后setColor进去
    - 然后再draw

{% asset_img 第11章桥接模式幻灯片20.png %}

{% asset_img 第11章桥接模式幻灯片21.png %}

{% asset_img 第11章桥接模式幻灯片22.png %}

{% asset_img 第11章桥接模式幻灯片23.png %}

{% asset_img 第11章桥接模式幻灯片24.png %}

{% asset_img 第11章桥接模式幻灯片25.png %}

{% asset_img 第11章桥接模式幻灯片26.png %}

{% asset_img 第11章桥接模式幻灯片27.png %}

{% asset_img 第11章桥接模式幻灯片28.png %}
